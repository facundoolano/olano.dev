---
title: Gleam, coming from Erlang
date: 2025-02-21 08:28:59
layout: post
lang: en
tags: [programming, web, projects, ideas]
draft: true
refs: [zenoferlang]
---
#+OPTIONS: toc:nil num:nil
#+LANGUAGE: en

I made some time to try Gleam, the type safe language that runs on the Erlang virtual machine.
For a couple of weeks, I used it to build a little [[https://github.com/facundoolano/news.olano.dev/][open source]] feed aggregator, that's now [[https://news.olano.dev/][live]].
These are my notes.

** why I'm interested in Gleam

I spent most of my career working with dynamic languages: Python, JavaScript, Clojure, finally Erlang. I don't claim to be an expert but the Erlang VM is the piece of technology I've became more intimately familiar with. There is no way around it, I think: if you're running Erlang in production sooner or later you'll be thinking in terms of processes, scheduling, failure modules, resource utilisation. I'd be still happily living in the BEAM, but it seems there aren't many companies willing to use it anymore. Or willing to hire Erlang devs from South America, anyway. Their loss.


After Erlang, I dabbled in Rust, both professionally and on [[deconstructing-the-role-playing-videogame][personal projects]], and I was very impressed by its typing system, its error handling, the developer experience it enabled. The thing is, Rust comes with all the systems programming overhead, which in my opinion is not a good bargain if you are not, you know, programming systems. Alas, I'm too old to pick up my garbage. And, coming from Erlang, Rust's async concurrency model (like JavaScript's, like Python's) just makes me very sad inside.

You can imagine why Gleam sounded interesting to me:

- I would like a Rust minus the memory management and with gentler concurrency;
- I would like a BEAM language without Erlang's rough edges and with the goodies of a modern type system[fn:1].

(I'm not claiming Gleam is one of those things, but it seemed close enough to spike my interest).

** the project

After happily running [[https://olano.dev/blog/reclaiming-the-web-with-a-personal-reader/][my personal feed reader]] for over a year, several spin-off projects have been coming to mind: turning my list of feeds into a blog roll, my list of favorites into a link blog, making a public version of my feed, etc.

The one unique feature of my reader is that I don't just sort posts chronologically but by "frequency bucket". If I follow a news site that publishes twice an hour and an essayist that publishes every two months, I want the essayist at the top of my list if they published yesterday, even though there are 30 more recent posts from the news site[fn:2]. To get this effect I distribute the feeds in frequency buckets and sort by reverse frequency first, publish date later. This is what the bucket calculation looks like in Gleam:

#+begin_src gleam
/// Calculate the frequency bucket of the feed,
/// by checking the average post frequency from the current
/// entry list. The higher rate the higher bucket.
fn calc_bucket(entries: List(FeedEntry)) -> Int {
  let by_date =
    list.sort(entries, by: fn(e1, e2) {
      birl.compare(e1.published, e2.published)
    })

  case list.first(by_date), list.last(by_date) {
    Ok(first), Ok(last) -> {
      let delta = birl.difference(last.published, first.published)
      let days = int.max(1, duration.blur_to(delta, duration.Day))
      let posts_per_day =
        int.to_float(list.length(entries)) /. int.to_float(days)

      case posts_per_day {
        // once a month or less
        n if n <=. 1.0 /. 30.0 -> 0
        // once week or less
        n if n <=. 1.0 /. 7.0 -> 1
        // once a day or less
        n if n <=. 1.0 /. 1.0 -> 2
        // 5 times a day or less
        n if n <=. 1.0 /. 5.0 -> 3
        // 20 times a day or less
        n if n <=. 1.0 /. 20.0 -> 4
        // more
        _ -> 5
      }
    }
    _, _ -> 0
  }
}
#+end_src

The minimal feed reader spin-off I could think of was then to:

  1. dump my followed list into a file,
  2. write a program that periodically pulls feed entries,
  3. sorts them in reverse frequency, and
  4. serve them as a link list.

** the design

The approach I took to design the app was: try to do what you would do in Erlang and see if that fits in Gleam.

What I thought about was:
- A set of [[https://www.erlang.org/docs/24/man/gen_server][gen_servers]], one per feed, that would periodically request the feed url, parse the entries and store them in the process state.
- Another gen_server that would periodically query each feed poller process for its most recent list of entries, sort them and dump them to a globally accessible [[https://www.erlang.org/docs/24/man/ets][ETS table]]. (That way, no process becomes a source of contention between clients trying to read the data, and the rebuilding of the data doesn't affect them either).
- A minimal web server that would just query the table and build an HTML list of the current entries.

I wouldn't bother with persisting the entries to a data store, although I would keep a file cache of feed responses to rebuild the state on app restarts without spamming the source sites.

In practice I managed to implement something very close to the initial design, with the exception that I opted for a [[https://www.erlang.org/doc/apps/erts/persistent_term.html][persistent_term]] instead of an ETS table, since I didn't want to get entries by key but read the full list on every request.

** env setup
- emacs lsp
- interesting how lsp-first gleam is

** learning

- you can read the tour in 20 mins and that will tell you most of what you need to know.
  - this perhaps speaks of the simplicity of the language, but it could also be that if you are already familiar with Rust and Erlang, most of the work is already done
  - then the hex docs for the libraries / builtin modules
  - for the more conceptual / idiomatic knowledge, google is obviously not an option. it seems like a lot of this knowledge lives in discord discussions (as opposed of e.g. github issues), so at least for the moment getting into the discord channel seems like a must for gleam

** the language

- simple
- stable / complete
- functional (akin to clojure and elixir)
- pipes
- namespaces

  https://erikarow.land/notes/gleam-favorite-feature

** error handling

- use <-
https://gleam.run/news/v0.25-introducing-use-expressions/

rust has the question mark operator
go has, uh, if statements
elixir has with
gleam has the use expression

I'm probably haven't reached my a-ha moment with use expressions, but in my short experience, I see more Result and Option return values than functions requiring callbacks, which for one requires me to do result.try and option.to_result to make it fit. What's much more problematic to me is that different functions would return differnt error types eg. Error(Nil), Error(String), Error(httpc.HttpError), so to make this fit I'd also need to coerce the errors to a common type, e.g. result.map_error(string.inspect), something that, as far as I understand, doesn't really fit in the context of `use` expressions.

https://discord.com/channels/768594524158427167/768594524158427170/1322962517051445300

I wonder if this is a trade-off made in favor of the javascript target, where concurrency is driven by callbacks.

** otp

- otp, different concepts, more distance, less mature than the rest of the language
- otp gen server, example how to reason about and write it

** erlang interop
- atoms
- erlsom
- ffi module
- decoder

** supervisors
- awkward initialization/connectivity
- static vs buggy
- no registered processes

** libraries

** exporting / deploying

look into attaching to release

** thoughts

- not sure if the designers or the community would agree but, to me, Gleam's killer feature is the erlang/otp integration
  - and this part, as opposed to the language design itself, doesn't seem to be stable yet
  - so no production, but pleasant to work with for personal project, a very nice way to revisit the erlang ecosystem

- the type system, lsp integration, error handling definitely bring something distinct to the ecosystem, and it surely will continue to get better.

- as far as a "rust without memory management and with better concurrency", I knew going in that Gleam could only be part of the answer. I don't think Gleam can be a general purpose language, just like Erlang can't: its VM makes very specific and unusual trade-offs, which don't make it a reasonable choice for applications that require computation efficiency or that don't benefit for high concurrency.

Perhaps the most interesting question, which I certainly won't try to answer here, is: are type safety and /let it crash/ compatible? Can they be complementary? Erlang is [[https://ferd.ca/the-zen-of-erlang.html][all about]] tolerating faults: accepting that you can't possibly catch all errors, and you'd be better off to design your application to recover in the presence of the unexpected. This has the consequence that some error handling code goes away, absorbed by the application structure and its supervision tree. Gleam, like Rust, makes you think preemptively about errors, and spend a much larger amount of time on handling them while writing code. One could argue that by doing this, an entire problem space disappears, leaving OTP to deal with the truly unexpected, as opposed to the silly typing errors that inevitably slip into all dynamically typed programs. There's a tension, but there's also an interesting balance to strike here, and I'm definitely curious to see how the Gleam community settles it.

*** Notes
[fn:1] No, not dialyzer.

[fn:2] In the reader, this is paired with an "auto mark as read on scroll" feature so the same "infrequent" posts aren't displayed at the top every time you open the app. This feature doesn't seem to be a good fit for a link aggregator without scrolling, but I'm still thinking about it.

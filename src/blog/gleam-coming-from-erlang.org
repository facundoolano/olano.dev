---
title: Gleam, coming from Erlang
date: 2025-02-21 08:28:59
layout: post
lang: en
tags: [programming, web, projects, ideas]
draft: true
refs: [zenoferlang]
---
#+OPTIONS: toc:nil num:nil
#+LANGUAGE: en

I made some time to try Gleam, the type safe language that runs on the Erlang virtual machine.
For a couple of weeks, I used it to build a little [[https://github.com/facundoolano/news.olano.dev/][open source]] feed aggregator, that's now [[https://news.olano.dev/][live]].
These are my notes.

** why I'm interested in Gleam

I spent most of my career working with dynamic languages: Python, JavaScript, Clojure, finally Erlang. I don't claim to be an expert but the Erlang VM is the piece of technology I've became more intimately familiar with. There is no way around it, I think: if you're running Erlang in production sooner or later you'll be thinking in terms of processes, scheduling, failure modules, resource utilisation. I'd be still happily living in the BEAM, but it seems there aren't many companies willing to use it anymore. Or willing to hire Erlang devs from South America, anyway. Their loss.

After Erlang, I dabbled in Rust, both professionally and on [[deconstructing-the-role-playing-videogame][personal projects]], and I was very impressed by its typing system, its error handling, the developer experience it enabled. The thing is, Rust comes with all the systems programming overhead, which in my opinion is not a good bargain if you are not, you know, programming systems. Alas, I'm too old to pick up my garbage. And, coming from Erlang, Rust's async concurrency model (like JavaScript's, like Python's) just makes me very sad inside.

You can imagine why Gleam sounded interesting to me:

- I would like a Rust minus the memory management and with gentler concurrency;
- I would like a BEAM language without Erlang's rough edges and with the goodies of a modern type system[fn:1].

(I'm not claiming Gleam is one of those things, but it seems close enough to spike my interest).

** the project

After happily running [[https://olano.dev/blog/reclaiming-the-web-with-a-personal-reader/][my personal feed reader]] for over a year, several spin-off projects have been coming to mind: turning my list of feeds into a blog roll, my list of favorites into a link blog, making a public version of my feed, etc.

The one unique feature of my reader is that I don't just sort posts chronologically but by "frequency bucket". If I follow a news site that publishes twice an hour and an essayist that publishes every two months, I want the essayist at the top of my list if they published yesterday, even though there are 30 more recent posts from the news site[fn:2]. To get this effect I distribute the feeds in frequency buckets and sort by reverse frequency first, publish date later. This is what the bucket calculation looks like in Gleam[fn:3]:

#+begin_src gleam
/// Calculate the frequency bucket of the feed,
/// by checking the average post frequency from the current
/// entry list. The higher rate the higher bucket.
fn calc_bucket(entries: List(FeedEntry)) -> Int {
  let by_date =
    list.sort(entries, by: fn(e1, e2) {
      birl.compare(e1.published, e2.published)
    })

  case list.first(by_date), list.last(by_date) {
    Ok(first), Ok(last) -> {
      let delta = birl.difference(last.published, first.published)
      let days = int.max(1, duration.blur_to(delta, duration.Day))
      let posts_per_day =
        int.to_float(list.length(entries)) /. int.to_float(days)

      case posts_per_day {
        // once a month or less
        n if n <=. 1.0 /. 30.0 -> 0
        // once week or less
        n if n <=. 1.0 /. 7.0 -> 1
        // once a day or less
        n if n <=. 1.0 /. 1.0 -> 2
        // 5 times a day or less
        n if n <=. 1.0 /. 5.0 -> 3
        // 20 times a day or less
        n if n <=. 1.0 /. 20.0 -> 4
        // more
        _ -> 5
      }
    }
    _, _ -> 0
  }
}
#+end_src

The minimal feed reader spin-off I could think of was then to:

  1. dump my followed list into a file,
  2. write a program that periodically pulls feed entries,
  3. sorts them in reverse frequency, and
  4. serve them as a link list.

** the design

The approach I took to design the app was: try to do what you would do in Erlang and see if that fits in Gleam.

What I thought about was:
- A set of [[https://www.erlang.org/docs/24/man/gen_server][gen_servers]], one per feed, that would periodically request the feed url, parse the entries and store them in the process state.
- Another gen_server that would periodically query each feed poller process for its most recent list of entries, sort them and dump them to a globally accessible [[https://www.erlang.org/docs/24/man/ets][ETS table]]. (That way, no process becomes a source of contention between clients trying to read the data, and the rebuilding of the data doesn't affect them either).
- A minimal web server that would just query the table and build an HTML list of the current entries.

I wouldn't bother with persisting the entries to a data store, although I would keep a file cache of feed responses to rebuild the state on app restarts without spamming the source sites.

The final result was very close to the initial design, with the exception that I opted for a [[https://www.erlang.org/doc/apps/erts/persistent_term.html][persistent_term]] instead of an ETS table, since I didn't want to get entries by key but read the full list on every request.

** env setup

I want to echo something I [[https://batsov.com/articles/2024/02/27/m-x-reloaded-the-second-golden-age-of-emacs/][recently read]]: this is a great time to be an Emacs user. Thanks to LSP, treesitter and [[https://github.com/radian-software/apheleia][apheleia]], I get a very consistent UX for new languages practically out of the box, something that a couple of years ago required a few days of tweaking to get right[fn:4].

I don't know if it's a particular inclination of the language designer or it's just how things are done today, but I was surprised to see how much emphasis is put in improving the developer experience and, specifically, adding features to the Language Server implementation for Gleam. During my first week of development, I constantly missed the ability to ~lsp-rename~ I have in other languages; during my second week, [[https://gleam.run/news/gleam-gets-rename-variable/][a new Gleam version]] came out adding that very feature!

** learning
- I learned most of why needed to know about the language in 30 mins, through the [[https://tour.gleam.run/][official tour]]. I had the advantage of being already familiar with Rust and Erlang, but I would say that the fact that everything can be covered so succinctly speaks of the effort that was put into keeping the language small and simple.
- For the standard libraries and external dependencies, their respective hex docs pages are the way to go.
- To pick up on conceptual discussions, ask questions and learn what's idiomatic, I found that (unfortunately for me) the discord channel is more effective than searching GitHub.

** the language

- The syntax pretty much feels like a functional subset of Rust, with Elixir-like pipes (~|>~) and a standard library adjusted to take advantage of them.
- The language specification is already stable, having reached 1.0 about [[https://gleam.run/news/gleam-version-1/][a year ago]].
- To me, one of the most important features of a language, and one that can be a good indicator of its "vibe" is how it deals with imports and namespaces. I think Gleam gets this /exactly/ right[fn:5], with qualified imports the easy default:

  #+begin_src Gleam
import gleam/io
import gleam/string as text

pub fn main() {
    // Use a function from the `gleam/io` module
    io.println("Hello, Mike!")

    // Use a function from the `gleam/string` module
    io.println(text.reverse("Hello, Joe!"))
}

  #+end_src

- The is no magic: no macros, no meta programming, no traits, no default or rest arguments. This is usually fine for me, with the exception of printing values for debugging, which becomes very tedious since everything needs to be coerced to a string and manually concatenated:
  #+begin_src gleam
io.println(
    "ERROR requesting "
    <> feed.url
    <> "\n"
    <> string.inspect(resp.status)
    <> " "
    <> string.inspect(error),
)
  #+end_src

** error handling

Error handling is always a contentious topic, especially in languages that have errors-as-values. There's usually some language support to ease the burden of checking results: Elixir has [[https://hexdocs.pm/elixir/1.15.8/Kernel.SpecialForms.html#with/1][with expressions]], Rust has the [[https://doc.rust-lang.org/rust-by-example/std/result/question_mark.html][question mark operator]], Go has, uh, if statements. The Gleam equivalent are [[https://tour.gleam.run/advanced-features/use/][use <- expressions]][fn:6].

Use is perhaps the only "special" bit of syntax of the language, and the one that requires more effort to get used to. One way to think about use is that it "absorbs" the callback argument of a function much like the pipe "absorbs" the first argument of an operation:

#+begin_src gleam
pub fn handle_request(request: HttpRequest) {
  logger.span("handle_request", fn() {
    database.connection(fn(conn) {
      case request.method {
        Post ->
          case database.insert(conn, request.body) {
            Ok(record) -> created_response(record)
            Error(exc) -> bad_request_response(exc)
          }
        _ -> method_not_allowed_response()
      }
    })
  })
}
#+end_src

Becomes:

#+begin_src gleam
pub fn handle_request(request: HttpRequest) {
  use <- logger.span("handle_request")
  use <- require_method(request, Post)
  use conn <- database.connection()

  case database.insert(conn, request.body) {
    Ok(record) -> created_response(record)
    Error(exc) -> bad_request_response(exc)
  }
}
#+end_src

I admit I haven't my got a-ha! moment with ~use~ yet, and I still struggle with error handling. Part of the problem, I think, is that ~use~ helps with callbacks, which are much less frequent than ~Result~ values, so function calls typically need to be wrapped in ~result.try~ and, since different functions tend to return different error types, this occasionally needs to be paired with ~result.replace_error~ to make it work:

#+begin_src Gleam
use resp <- result.try(
  httpc.configure()
  |> httpc.follow_redirects(True)
  |> httpc.dispatch(req)
  |> result.replace_error(RequestError),
)
io.println(resp.body)
#+end_src

One of the patterns that emerges of this, I believe, is to define an app-specific error type and use it everywhere, mapping external errors to it.

** erlang interop
- more distance compared to eg elixir
  - part bc of the type system
  - part bc gleam seems to want to be able to stand conceptually on its own, independent of its target platform (it compiles to JavaScript in addition to Erlang)
- example persistent term
- atoms, charlists
- erlsom
- fool the type checker
- decoder
- ffi module
  - TODO example parser


** otp

- otp, different concepts, less mature than the rest of the language
- otp gen server, example how to reason about and write it

- supervisors
  - awkward initialization/connectivity
  - static vs buggy
  - no registered processes

** exporting / deploying

look into attaching to release

** thoughts

- not sure if the designers or the community would agree but, to me, Gleam's killer feature is the erlang/otp integration
  - and this part, as opposed to the language design itself, doesn't seem to be stable yet
  - so no production, but pleasant to work with for personal project, a very nice way to revisit the erlang ecosystem

- the type system, lsp integration, error handling definitely bring something distinct to the ecosystem, and it surely will continue to get better.

- as far as a "rust without memory management and with better concurrency", I knew going in that Gleam could only be part of the answer. I don't think Gleam can be a general purpose language, just like Erlang can't: its VM makes very specific and unusual trade-offs, which don't make it a reasonable choice for applications that require computation efficiency or that don't benefit for high concurrency.

Perhaps the most interesting question, which I certainly won't try to answer here, is: are type safety and /let it crash/ compatible? Can they be complementary? Erlang is [[https://ferd.ca/the-zen-of-erlang.html][all about]] tolerating faults: accepting that you can't possibly catch all errors, and you'd be better off to design your application to recover in the presence of the unexpected. This has the consequence that some error handling code goes away, absorbed by the application structure and its supervision tree. Gleam, like Rust, makes you think preemptively about errors, and spend a much larger amount of time on handling them while writing code. One could argue that by doing this, an entire problem space disappears, leaving OTP to deal with the truly unexpected, as opposed to the silly typing errors that inevitably slip into all dynamically typed programs. There's a tension, but there's also an interesting balance to strike here, and I'm definitely curious to see how the Gleam community settles it.

*** Notes
[fn:1] No, not dialyzer.

[fn:2] In the reader, this is paired with an "auto mark as read on scroll" feature so the same "infrequent" posts aren't displayed at the top every time you open the app. This feature doesn't seem to be a good fit for a link aggregator without scrolling, but I'm still thinking about it.

[fn:3] Can you spot the bug?

[fn:4] My Emacs setup for Gleam is just [[https://github.com/gleam-lang/gleam-mode][gleam-ts-mode]] and ~(add-hook 'gleam-ts-mode-hook 'lsp-deferred)~.

[fn:5] I finally decided to put learning Gleam in my short to-do list after reading about its namespaces in [[ https://erikarow.land/notes/gleam-favorite-feature][this blog post]].

[fn:6] More about use expressions [[https://gleam.run/news/v0.25-introducing-use-expressions/][here]] and [[https://erikarow.land/notes/using-use-gleam][here]].

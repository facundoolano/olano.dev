---
title: Domain-Driven Design Revisited
subtitle: Reading notes
date: 2025-05-25 15:29:30
layout: post
lang: en
tags: [software, books, tldr]
refs: [ddd]
draft: true
excerpt: all that glitters is not Enterprise JavaBeans
---
#+OPTIONS: toc:nil num:nil
#+LANGUAGE: en

#+BEGIN_EXPORT html
<div class="text-center">
 <a href="https://vladikk.com/page/books/#learning-domain-driven-design-o-reilly-2021"> <img src="{{site.config.static_root}}/img/ddd.jpg" width="320"></a>
</div>
#+END_EXPORT

** Background

Early in my career, when I was working at a Java shop, there was a lot of buzz about /enterprise applications/. You would use Java /Enterprise/ Edition to apply Patterns of /Enterprise/ Architecture, implemented through /Enterprise/ Java Beans. It wasn't clear to me what made some applications more /enterprise/ than others, or why following a specific set of ceremonies was supposed to yield more adequate solutions to their problems. I tended to dismiss these programming concepts that seemed to exist exclusively inside the Java +echo chamber+ ecosystem.

I shortly moved away from that Java shop and from Java programming in general to work with other languages on a few web apps, a media outlet, an MTG online community, a SaaS provider, an ad tech company, a crypto startup, and then an AI one[fn:1]. Last year I took what I would call a less pretentious, more [[https://boringtechnology.club/][technologically boring]] job in the healthcare sector. The challenge in this new company comes not from scale or growth or sophisticated tools but from the complexity of the domain---from the need to design an organization, and consequentially a software architecture, that automates and eventually simplifies its business processes.

This shift in focus is why I went back to the basics and have been reading about [[software-design-is-knowledge-building][knowledge building]] and [[unit-testing-principles/][testing-as-design]]. It was through the /Unit Testing/ book that I finally came to terms with the /enterprise application/ concept:

#+begin_quote
An enterprise application is an application that aims at automating or assisting an organization’s inner processes. It can take many forms, but usually the characteristics of an enterprise software are
-  High business logic complexity
-  Long project lifespan
-  Moderate amounts of data
-  Low or moderate performance requirements
#+end_quote

<This sounded like a pretty accurate description of what I work on at my current job,
especially when contrasted with what I did before>. Given the kind of challenges I currently face---fleshing out business processes, reconciliating terminology, breaking apart the legacy monolith, figuring out what the domain entities are and who should own them, etc.---a natural next step for me was to take another look at Domain-Driven Design.

** Design

I picked up Vlad Khononov's /Learning Domain-Driven Design/ as a modern alternative to the classic Eric Evan's blue book. It summarizes and updates the same ideas, and finally relates them to newer techniques like microservices, event-driven architecture, and data mesh. The first part, /Strategic Design/, covering the core DDD concepts, was the most useful for my purposes.

*** Summary

- A *business domain* defines a company’s main area of activity, the service the company provides to its customers. A company can operate on multiple domains or change them over time.
- A *subdomain* is a fine-grained area of business activity. All of a company’s subdomains form its business domain. From a technical perspective, subdomains resemble sets of interrelated, coherent use cases. Such sets of use cases usually involve the same actor, the business entities, and they all manipulate a closely related set of data. Domain-driven design distinguishes between three types of subdomains:
  - A *core subdomain* is what a company does differently from its competitors. This may involve inventing new products or services or reducing costs by optimizing existing processes. A core subdomain that is simple to implement can only provide a short-lived competitive advantage. Therefore, core subdomains are naturally complex.
  - A *generic subdomain* is a business activity that all companies are performing in the same way. They are generally complex and hard to implement but battle-tested implementations are widely available.
  - A *supporting subdomain* is one that supports the company's business without offering a competitive advantage. Supporting software has low business logic complexity and therefore, it's cheaper to implement.
    #+begin_export html
<br/>
#+end_export

| Subdomain Type | Competitive advantage | Complexity | Volatility | Implementation     | Problem     |
|----------------+-----------------------+------------+------------+--------------------+-------------|
| Core           | Yes                   | High       | High       | In-house           | Interesting |
| Generic        | No                    | High       | Low        | Buy/adopt          | Solved      |
| Supporting     | No                    | Low        | Low        | In-house/outsource | Obvious     |

#+begin_export html
<br/>
#+end_export

- *Domain experts* are knowledge authorities in the software’s business domain. They are either the people coming up with requirements or the software’s end users. The software is supposed to solve their problems. Systems analysts and engineers are transforming their mental models of the business domain into software requirements and source code.
  - A software project’s success depends on the effectiveness of knowledge sharing between domain experts and software engineers.
- An *ubiquitous language* is the terminology that describes the business domain, shared between all project related stakeholders. It's intended as a means for communication between domain experts and the project team members, removing the need of translations and intermediaries (system analysts, product owners).
  - It should consist of business domain-related terms, not technical jargon.
  - It should be consistent, without ambiguous or synonymous terms.
  - It should be constantly evolved and validated.
  - It should be cocreated between domain experts and team members. The preexisting business language used by experts may not be effective for domain modeling.
- Since the ubiquitous language needs to be consistent and reflect the domain expert's mental model, but different domain experts can have conflicting models, the language is divided into smaller languages with specific areas of application, called *bounded contexts*.
  - Defining the scope of a ubiquitous language---its bounded context---is a strategic design decision. The larger the boundary, the harder to keep it consistent; the smaller, the more integration overhead the design induces.
  - each bounded context should be implemented as an individual service/project.
  - each bounded context should be owned by one team only
- A bounded context is different from a subdomain.
  - both are ways of decomposing a business domain.
  - Subdomains are /identified/ as part of the business domain analysis. They are a set of use cases that are discovered.
  - Bounded contexts are /designed/ to model the business as smaller, more manageable problem domains.
- Bounded context express different, internally-conflicting, views of the business domain, but they still need to interact with each other to build useful systems. There are a few approaches the owning teams can take on the integration:
  - An ad hoc *partnership*, where changes are coordinated between the teams.
  - A *shared kernel*, where a subset of both bounded contexts is shared and kept consistent.
  - A *conformist* integration, when one of the bounded contexts (the consumer) inherits the <terminology> of the other (the supplier).
  - *anti corruption layer*, where the consumer context adjusts to the supplier <terminology> through a separate translation layer, to "protect itself" from upstream changes.
  - *open host service* where its the upstream bounded context that exposes a public interface to protect its consumers from internal changes.
  - *separate ways*, where it's considered cheaper to duplicate logic and definitions to avoid the integration entirely.

*** Commentary

1. I find the distinction of core, generic, and supporting subdomains useful to build heuristics for technical decision making, e.g. to decide where it's worth investing[fn:2]: if you're investing in sophisticated software development outside your core subdomain, you're probably doing it wrong. And if you don't know what your core subdomain is, then you are in trouble!

2. I wholeheartedly sympathize with the pursuit of an ubiquitous language. Having to stop and think because you don't know what a word means or how to best convey a specific concept to a particular audience adds a fatal amount. Domain modeling in those conditions is like working on a team where everyone has short-term memory loss. If you don't build language you can't build knowledge, and if you don't build knowledge you can't build software.

3. Trying to push an universal domain model across a large company tends to fail like Esperanto. Even if such universal model was possible, trying to jump directly into it is like the infamous software rewrite from scratch. It's more realistic to start from where you are at, improving iteratively, knowing what good enough looks like, and when it's better to stop modeling---tolerating imperfection. The bounded context is a great tool for that, it's how you reconcile conflicting domain views and terminology, enabling useful and internally consistent (maintainable) software.

4. <Beyond the co-creation of a shared language, I believe the best outcomes stem from a feedback loop between domain experts and software designers: designers should be constantly incorporating business knowledge from the experts, but also, [[a-note-on-essential-complexity][ideally]], become catalysts for change, e.g. not just capturing domain processes and rules but discovering opportunities to simplify them.

5. <it requires a lot of collaboration from domain experts: a tight collaboration with software designers to articulate and transfer domain knowledge, and to co-create an ubiquitous language.
  this is a potential weakness of the methodology because most real-world organization are not set up for this type of collaboration
  - companies tend to put intermediaries (product owners or software analysts) in between[fn:3].
  - lack an incentive to spend time on the software and to change their current language

6. Some of the challenges are acknowledged in the book, but without offering satisfying solutions, perhaps because they involve organizational design and politics rather than software. <The two ways I see this work in practice are:
  - The company direction is already sold on DDD and can mandate the domain experts to collaborate: the organizational the supports this development strategy /by design/.
  - The software designers are on their own, and need to do what the book calls /undercover DDD/. In this case, they can leverage the software itself as a tool to favor DDD. Using the ubiquitous language as example, designers can either chose to adopt terminology from experts as is, or push for consistency by changing it through the software they build (at the risk of getting it wrong).

** Development
- my least favorite part of the book is where it describes tactical design
- I found it too prescriptive, too pattern-y, perhaps too indebted to the original applications of the DDD ideas that, coupled with some of the patterns for Enteprise architectures described in Martin Fowler's book.

- This part converge in to a design heuristics decision-tree, where the subdomain type and a few other attributes cascade into each design decision (data modeling, application architecture, testing strategy):
  #+BEGIN_EXPORT html
<div class="text-center">
 <img src="{{site.config.static_root}}/img/heuristics.png">
</div>
#+END_EXPORT


- I should stress that the tone of the book is not dogmatic, heuristic usually come with the required disclaimers.
- but nevertheless, the problem is that the discussion and the emphasis is still put on specific techniques rather than in the principles they derive from. I found the techniques of little applicability in my day to day, so I was hard to keep up with the discussion.

As an example, the book discusses low level data modeling patterns like Transaction Script, Active Record, and Domain Model.
- any real world project that I've worked on professionally had a recommended, standardized stack: e.g. the data managed by Django, Rails, SqlAlchemy, etc. So I'm much less interested in seeing implementation details of a domain model or active record, than in seeing what are the principles behind using one or another, so I can try to bend my available tools to get some of those benefits, without having to sell a tech stack change /in addition/ to selling the domain-driven design model.

** Deployment

The book starts to pick up again by the end of Part III when it tackles evolving design decisions and how to implement DDD in "brownfield" projects.
- It's telling that this topic is only addressed in a few pages of chapter 13. I can't help but feel this choice is backwards.
  - In 2025 (or, to be fair, 2021, when the book was published) I wish the literature would stop assuming greenfield projects by default.
  - again, at the end of the day, what makes or breaks DDD is not the application of specific programming techniques but the cultivation of an environment that favors knowledge transfer between business experts and software designers---letting the domain drive the design. There are no recipes for that, and it would hard to fill a programmer-oriented book on the topic.
  - any business complex enough to warrant domain-specific software (that is, any /enterprise/) in 2025 will necessarily already exist in a jungle of overcomplicated legacy software. <Any useful software development methodlogy needs to be built around that assumption
  - maybe I'm looking for something like arch modernization

- I unexpectedly found a lot of value in the last few chapters, when the DDD approach is integrated with other methodologies, even if I'm not using any of them.
- The chapter on microservices, in particular, was one of the best treatments I've seen of the subject, putting it not only in the context of DDD but of modular design as explained by John Ousterhout and of the work by one Glenford Myers, to whom we owe this gem:

#+begin_quote
There is much more to the subject of complexity than simply attempting to minimize the local complexity of each part of a program. A much more important type of complexity is global complexity: the complexity of the overall structure of a program or system (i.e., the degree of association or interdependence among the major pieces of a program).
#+end_quote

- the treatment is similar to this earlier blog post, although I prefer the one in the book.
- /Learning Domain-Driven Design/ worked well as a refresher of the DDD core concepts and to familiarize with a few techniques I'd only knew by name. <I didn't get quite as much as I was expecting in terms of applicability to my day to day job, but the last few chapters convinced me that the author is onto something. I found out that he recently published a more principled book on software design, so I'll definitely be checking that one out.

*** Notes
[fn:1] Which, read like that, kind of explains why I ended up needing a career break.
[fn:2] This is similar to the [[https://mcfunley.com/choose-boring-technology][innovation tokens]] concept.
[fn:3] Understandably: more often than not, engineers are unwilling or unprepared to talk in non technical terms; more often than not, business people lack the patience of the time to deal with engineers.

---
title: Domain-Driven Design Revisited
date: 2025-05-25 15:29:30
layout: post
lang: en
tags: [software, books, tldr]
refs: [ddd]
draft: true
excerpt: all that glitters is not Enterprise JavaBeans
---
#+OPTIONS: toc:nil num:nil
#+LANGUAGE: en

#+BEGIN_EXPORT html
<div class="text-center">
 <a href="https://vladikk.com/page/books/#learning-domain-driven-design-o-reilly-2021"> <img src="{{site.config.static_root}}/img/ddd.jpg" width="320"></a>
</div>
#+END_EXPORT

** Background

Early in my career, when I was working at a Java shop, there was a lot of buzz about /enterprise applications/. You would use Java /Enterprise/ Edition to apply Patterns of /Enterprise/ Architecture, implemented through /Enterprise/ Java Beans. It wasn't clear to me what made some applications more /enterprise/ than others, or why following a specific set of ceremonies was supposed to yield more adequate solutions to their problems. I tended to dismiss these programming concepts that seemed to exist exclusively inside the Java +echo chamber+ ecosystem.


I shortly moved away from that Java shop and from Java programming in general to work with other languages on user-facing web apps, media publishing, ad tech, crypto, and AI startups[fn:1]. Last year I took what I would call a less pretentious, more [[https://boringtechnology.club/][technologically boring]] job in the healthcare sector. The challenge in this new company comes not from scale or growth or sophisticated tools but from the complexity of the domain---from the need to design an organization, and consequentially a software architecture, that automates and eventually simplifies its business processes.

This shift in focus is why I went back to the basics and have been reading about [[software-design-is-knowledge-building][knowledge building]] and [[unit-testing-principles/][testing-as-design]]. It was through that /Unit Testing/ book that I finally came to terms with the /enterprise application/ concept:

#+begin_quote
An enterprise application is an application that aims at automating or assisting an organizationâ€™s inner processes. It can take many forms, but usually the characteristics of an enterprise software are
-  High business logic complexity
-  Long project lifespan
-  Moderate amounts of data
-  Low or moderate performance requirements
#+end_quote

This sounded like a pretty accurate description of what I work on at my current job,
especially when contrasted with what I did before. Given the kind of challenges I currently face---fleshing out business processes, reconciliating terminology, breaking apart the legacy monolith, figuring out what the domain entities are and who should own them, etc.---a natural next step for me was to take another look at Domain-Driven Design.

[fn:1] Which, read like that, kind of explains why I ended up needing a career break


** Strategic Design

I picked up Vlad Khononov's /Learning Domain-Driven Design/ as a modern alternative to the classic Eric Evan's blue book. It summarizes and updates the same ideas, and finally relates them to newer techniques like microservices, event-driven architecture, and data mesh. The first part, /Strategic Design/, covering the core DDD concepts, was the most useful for my purposes.

*** Definitions
- domain
- subdomain
- subdomain types
- table
- ubiquitous language
- bounded contexts
- difference between subdomain and bounded context

*** Commentary

- I find this separation of the business in core, generic, and supporting subdomain useful to build heuristic around technical decision making, e.g. where it's worth investing, along the lines of the "innovation tokens" concept.
- I wholeheartedly agree with the need to strive for a ubiquitous language, I see the improbability of making a single version of the domain work for the entire company, and thus see value in Bounded Context as a software design tool.
- What I think is lacking in the discussion of the book:
  - it places too much expectations on domain experts
  - in practice, they are more like subdomain experts, at times with conflicting views
  - companies tend to put intermediaries (product owners) in between. it's hard to carry the intention to build bounded context through these intermediaries
  - I think there should be a two-way feedback loop: software designers should rely on experts to incorporate the business, but software should also, ideally [LINK], be a driver for domain change, e.g. not just capturing the business processes and rules but surfacing opportunities to simplifying them.
  - business experts and system users don't typically have an incentive to adapt to the software---specifically, they would hardly be interested in changing their habits to accommodate an externally mandated ubiquitous language.
    - maybe if this is mandated from decision makers already bought into the DDD model. This is not very realistic in my experience.
    - maybe if this change in language is driven by software adoption. if a piece of software offers better business capabilities with a different domain language, that may be a reason for users to adjust. (This of course, carries the risk of pushing inconsistent language if engs don't make it a priority or are not familiar enough with the business).

Some of these challenges of applying the theory are covered later on the book, but unfortunately <too little too late.

** Applying DDD
- my least favorite part of the book is where it describes tactical design
- I found it too prescriptive, too pattern-y, perhaps too indebted to the original applications of the DDD ideas that, coupled with some of the patterns for Enteprise architectures described in Martin Fowler's book.

- This part converge in to a design heuristics decision-tree, where the subdomain type and a few other attributes cascade into each design decision (data modeling, application architecture, testing strategy):
  #+BEGIN_EXPORT html
<div class="text-center">
 <img src="{{site.config.static_root}}/img/heuristics.png">
</div>
#+END_EXPORT


- I should stress that the tone of the book is not dogmatic, heuristic usually come with the required disclaimers.
- but nevertheless, the problem is that the discussion and the emphasis is still put on specific techniques rather than in the principles they derive from. I found the techniques of little applicability in my day to day, so I was hard to keep up with the discussion.

As an example, the book discusses low level data modeling patterns like Transaction Script, Active Record, and Domain Model.
- any real world project that I've worked on professionally had a recommended, standardized stack: e.g. the data managed by Django, Rails, SqlAlchemy, etc. So I'm much less interested in seeing implementation details of a domain model or active record, than in seeing what are the principles behind using one or another, so I can try to bend my available tools to get some of those benefits, without having to sell a tech stack change /in addition/ to selling the domain-driven design model.

** Relationships With Other Models

The book starts to pick up again by the end of Part III when it tackles evolving design decisions and how to implement DDD in "brownfield" projects.
  - TODO review topics: eg. how to sell DDD or how to do it undercover, or to partially.
- I can't help but feel the ordering here is backwards. In 2025 (or, to be fair, 2021, when the book was published) I wish the literature would stop assuming greenfield projects by default.
  - maybe I'm looking for something like arch modernization

- I unexpectedly found a lot of value in the last few chapters, when the DDD approach is integrated with other methodologies, even if I'm not using any of them.
- The chapter on microservices, in particular, was one of the best treatments I've seen of the subject, putting it not only in the context of DDD but of modular design as explained by John Ousterhout and of the work by one Glenford Myers, to whom we owe this gem:

#+begin_quote
There is much more to the subject of complexity than simply attempting to minimize the local complexity of each part of a program. A much more important type of complexity is global complexity: the complexity of the overall structure of a program or system (i.e., the degree of association or interdependence among the major pieces of a program).
#+end_quote

- the treatment is similar to this earlier blog post, although I prefer the one in the book.
- /Learning Domain-Driven Design/ worked well as a refresher of the DDD core concepts and to familiarize with a few techniques I'd only knew by name. <I didn't get quite as much as I was expecting in terms of applicability to my day to day job, but the last few chapters convinced me that the author is onto something. I found out that he recently published a more principled book on software design, so I'll definitely be checking that one out.

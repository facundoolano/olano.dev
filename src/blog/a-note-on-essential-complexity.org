---
title: A Note on Essential Complexity
date: 2024-06-13 14:16:19
layout: post
lang: en
tags: [software]
draft: true
cover-img: assets/img/labrea.jpg
image: assets/img/tarpit.png
---
#+OPTIONS: toc:nil num:nil
#+LANGUAGE: en

There's a world in which reducing complexity is the main duty of a software engineer. John Ousterhout summarizes it well:
  - quote
  - the model may not be universally true, but let's assume it for the purposes of this discussion.
- The seminal essay to talk about software complexity is fred brooks NSB. there he distinguishes between essence and accident in software, and says that complexity is part of the essence of software development ---the thing that determines the limits of our productivity.
- Moseley and Marks, in /Out of the Tar Pit/, refine Brooks definitions to make them more useful to reason about.
  - accidental + essential complexity definitions
  - some accidental is necessary
  - the job is to minimize + assist
- Mosely & Marks remark, contrary to brooks, that accidental complexity still accounts for most of the complexity of the software, so it's worth trying to reduce it. I agree with them
  - my personal experience showed me that a lot of the complexity we have to deal-with is self inflicted: inclination for over engineering, following trends, shortcuts due to tactical programming mindset, making decisions at a stage when we don't know enough yet.
  - M&M also say that essential complexity is, by definition, the part that's inherent to the problem, out of our purview, what we can't change. I want to challenge this assumption
    - <or, better put, exploring what happens when engineers are willing to assume the responsibility of attacking essential complexity as part of their jobs, even if that means redefining the problems from the user standpoint. Even if it means operating beyond the limits of the software.
# [maybe better later like in spanish? what makes for better readability]

#+BEGIN_CENTER
\lowast{} \lowast{} \lowast{}
#+END_CENTER

- Let's go back to NSB. Brooks seems agree with M&M in that some of the essential complexity is explained by the fact
that software needs to conform to the external world:

#+begin_quote
Much of the complexity [the software engineer] must master is arbitrary complexity, forced without rhyme or reason by the many human institutions and systems to which his interfaces must conform. (…) In many cases the software must conform because it has most recently come to the scene. In others it must conform because it is perceived as the most conformable. But in all cases, much complexity comes from conformation to other interfaces; this cannot be simplified out by any redesign of the software alone.
#+end_quote

But, then, he admits that software itself can make users conform to it, in a sense transforming the world:

#+begin_quote
The buyer of a $2-million machine in 1960 felt that he could afford $250,000 more for a customized payroll program, one that slipped easily and nondisruptively into the computer-hostile social environment. Buyers of $50,000 office machines today [1986] cannot conceivably afford customized payroll programs; so they adapt their payroll procedures to the packages available. Computers are now so commonplace, if not yet so beloved, that the adaptations are accepted as a matter of course.
#+end_quote

This doesn't come as a surprise to us: we've been seeing for decades how human behavior can be shaped by the software they use: email, instant messaging, video conferencing, social networks, content streaming.

If we admit that software has the potential to change people and organizations, then the problems that software solve can be redefined: its essence is not necessarily set in stone but open to debate, part of what the engineer can work with. In the /"No Silver Bullet" Refired/ retrospective, Brooks quotes a reader that best summarizes this attitude:

#+begin_quote
In my experience most of the complexities which are encountered in systems work are symptoms of organizational malfunctions. Trying to model this reality with equally complex programs is actually to conserve the mess instead of solving the problems.
#+end_quote

With this in mind we can simplify the job of the engineer from "Minimizing /accidental/ complexity and assisting with /essential/ complexity" to "Minimizing complexity /of any kind/".

#+BEGIN_CENTER
\lowast{} \lowast{} \lowast{}
#+END_CENTER

<
While "redefining the problem" may sound like cheating, this is second nature to senior engineers.
- why do we need this?
- making sure we're solving the right problem
- code is a liability, not an asset
- better than writing or deleting software, the best outcome is prevent the wrong software from being written in the first place
>

TODO
- let's use a legacy system as an example of how to apply this attitude
- find a complex piece of software, it can happen that:
  - TODO

Marinanne Bellotti, kill it with fire

#+begin_quote
When we encountered systems that had been forgotten and we couldn’t figure out what they were doing, we would usually just turn them off and see what happened. (…) When we turned off a system, we waited for someone to complain. That person was either the system owner or the owner of a downstream dependency, but either way, we ended the experiment with more information about what the system was doing than we started with. (…) If no one complained, we tended to just leave the system off and move on.
#+end_quote

#+BEGIN_CENTER
\lowast{} \lowast{} \lowast{}
#+END_CENTER

It's interesting to see what happens when we take this argument to its extreme; software engineers acting as the philosophical razor, removing the complexity of the world. They could:
- envision simpler implementations for the systems, then exercise their influence on the organizations that use them, pushing their processes to converge with the desired implementation ---a sort of userland reverse Conway;
- automate employees, including the engineers themselves, out of a job;
- simplify systems, along with the organizations that own them, out of existence.

Of course, this reduction to the absurd is a consequence of taking our initial premise beyond its reasonable scope of application. We started with the assumption that the software engineer's sole purpose is to minimize complexity, detached from the economic realities that drive their work.

Let that be a reminder that, since our work indeed has the power to transform people and organizations, we can't wield it unconsciously, as mere instruments, hiding behind the comfort of an abstraction. We occasionally need to look into the method definition.

-----
/The ideas in this post were [[file:posdata-sobre-la-complejidad-esencial][previously explored]] in Spanish./

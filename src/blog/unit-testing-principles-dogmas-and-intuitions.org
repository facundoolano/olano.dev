---
title: "Unit Testing: dogma, intuition, and principles"
date: 2025-01-18 13:57:57
layout: post
lang: en
tags: [software, books, tldr]
draft: true
refs: [clarity, testing]
---
#+OPTIONS: toc:nil num:nil
#+LANGUAGE: en

** Background
[[https://enterprisecraftsmanship.com/book/][Unit Testing: Principles, Practices, and Patterns]] by Vladimir Khorikov


- how did I learn about the book
  - pragmatism
  - readability?
  - unit of behavior
- i bought it but didn't consider reading it seriously
  - didn't even include it in my list
- because, I had a good idea of what worked and what didn't with testing, been doing it for a decade an a half. probably could pick some good stuff from the book, but I lacked the motivation. there were plenty of other books that seemed a better time investment.

I knew enough to get by.

things changed after recently starting a new job and joining a new team.
the scenario there was different than what I was used to. you see, I had experience in these:
- extending an already effective test suite
- adding tests as part of greenfield project development
- adding tests to an undertested old project
- improving or extending a test suite that team agreed was ineffective

What I hadn't dealt with in the past was a disciplined team, with an extensive but ineffective test suite. What's worse, they didn't quite realise it was ineffective. Unit tests took a lot of effort to write, they didn't catch many bugs, and they broken on small refactors, but that wasn't perceived as a problem.

I had opinions about testing practices and ideas on how to improve this test suite. But they were based on my past experience---ultimately, on subjective intuitions. I would need something better than that to convince the team to change their habits and to justify the effort to my manager.

But before getting into that, what were those intuitions?

** What I thought I knew about testing

- TODO copy list from notebook

(I'm a proud [[https://grugbrain.dev/#grug-on-testing][Grug Brained Developer]])

- the specific problems I detected in my new project's test suite
- it was obvious I will have to spend time improving the testing approach, either with dedicated tasks or as I worked on other stuff
- reading the unit testing book may equip me with tools to spend the time effectively, to avoid pitfalls that could <discredit> the effort, but, most importantly, it would arm me with justification for the cultural change I wanted to <foster>

the book proved a perfect fit for my intentions, I think mainly because of it's principled approach:
TODO quote introduction to the bookr


** Dogma, intuition, and principles

** Commentary

- it aligns with a lot of my intuition, but derives them from core principles (no subjectivity and no dogma)
- it's not dogmatic: it focuses on principles, not in rules, and not in methodologies or tools
- perhaps because of that, it's more a software design than a software testing book. which is interesting: striving for a good test suite is a good way to drive the system design. which is a totally different mindset than trying to drive the design by writing tests.

- what is an enterprise application?

** Highlights

*** Chapter 1: The goal of unit testing
- The goal of testing is to enable /sustainable/ growth of the software project
- Code is a liability, not an asset. It's always better to solve problem with the minimum amount of code. Testing code is no different on this regard.
- Some tests are valuable and contribute a lot to overall software quality. Others don't. They raise false alamrs, don't help you catch regression errors, and are slow and difficult to maintain.
- You need to consider both the test's value and its upkeep cost---time spent in:
  - refactoring the test whe you refactor the underlying code
  - running the test on each code change
  - dealing with false alarms raised by the test
  - reading the test when you're trying to understand how the underlying code behaves
- To enable sustainable project growth, you have to exclusively focus on high-quality tests---those are the only type of tests that are worth keeping in the test suite.
- Coverage metrics are a good negative indicator (low coverage means you're not testing enough) but a bad positive one (high coverage doesn't guarantee good testing quality).
  - Targeting a specific coverage number creates a perverse incentive that goes against the goal of unit testing.
- A successful test suite has the following properties:
  - it's integrated into the development cycle
  - it provides maximum value with minimum maintenance costs
  - it targets only the most important parts of your code base
    - in most applications this is the domain model
      - in order to follow this guideline, you should isolate the domain model from the non-essential parts of the code base.

*** Chapter 2: What is a unit test?
- A unit test is an automated test that:
  - verifies a small piece of code (also known as a /unit/),
  - does it quickly,
  - and does it in an isolated manner.
- There are two distinct views on how to approach unit testing: the /classical/ and the /London/ (a.k.a. /mockist/) schools of unit testing.
  - The root of the differences is the isolation attribute. The London school views it as isolation of the system under test from its collaborators, whereas the classical school views it as isolation of unit tests themselves from each other.
- Tests shouldn't verify /units of code/. Rather, they should verify /units of behavior/, something that is meaningful for the problem domaiun and, ideally, something that a business person can recognize as useful. The number of classes it takes to implement such a unit of behavior is irrelevant. The unit could span across multiple classes or only one class, or even take up just a tiny method.
- A test should tell a story about the problem your code helps to solve, and this story should be cohesive and meaningful to a non-programmer.
- Instead of reaching for mocks to test a large, complicated graph of interconnected classes, you should focus on not having such a graph of classes in the first place. More often than not, a large class graph is a result of a code design problem.
- The London style tends to produce tests that couple to the implementation more often than the classical style. This is the main objection against the ubiquitous use of mocks and the London style in general.
- Assuming the classical view, a unit test can then be redefined as an automated test that:
  - verifies a /single unit of behavior/,
  - does it quickly,
  - and does it in isolation /from other tests/.

*** Chapter 4: The four pillars of a good unit test

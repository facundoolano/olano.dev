---
title: Deconstructing the Role-Playing Video Game
date: 2024-07-08 10:54:18
layout: post
lang: en
tags: [projects, ideas, videogames]
draft: true
image: assets/img/rpgcli.png
---
#+OPTIONS: toc:nil num:1
#+LANGUAGE: en

/Following up on my [[a-computing-magazine-anthology][previous post]], today I want to write about an idea for a [[https://github.com/facundoolano/rpg-cli][rpg-cli]] spin-off. rpg-cli is one of my fondest personal projects and I never properly documented its development, so I'll start this post off by doing just that./

#+begin_export html
<h2>Contents</h2>
#+end_export
#+TOC: headlines 3

** The simplest thing that could possibly work

I was a little bored at work. I had the spare time, I could've used a side project. It had been a while since I worked on a video game, and I was having that kind of itch. In the past few years I had finished many classic Japanese RPGs: /Final Fantasy VI/, /Chrono Trigger/, /Suikoden 2/, /Final Fantasy Tactics/. That experience was fresh in my head, so I felt compelled to try experimenting with that genre. But, to stay motivated enough to go through with them, I need personal projects to be short-lived, yielding something somewhat finished after a few month. I wasn't going to embark on a full game development project on my own.


I've played JRPGs long-enough that I don't pay much attention to the characters or the plot anymore; I like the pretty pixels, yes, but most importantly I'm drawn to its underlying systems. Explore the map, visit cities, clear dungeons. Kill monsters, level up, buy equipment. Character stats, turn-based combat, leveling system. To me, classic JRPGs are pure mechanism, a kind of puzzle.

Was there some way of getting the fun out of building such a mechanism---of solving that puzzle---, wrapping it with the minimal amount of functionality, the simplest thing that could possibly pass as a video game? How much could I have peeled off and still gotten an RPG? One answer was obvious: off with the story, the plot, the dialogues[fn:2]. But that wouldn't be enough: the real blocker were the graphics, I needed some way to workaround them in all their rabbit-hole, yak-shaving glory.

I had recently seen how /Final Fantasy Tactics/ developers fit most of the standard RPG elements, save the battle sequences, into menus. Could I have done something in that direction?
If it was today, I'd consider building a mini game with PICO-8 or an ASCII roguelike interface. At the time, I went with a trick had worked for me before: replacing the graphics with text[fn:1]. Except that, you know what's narrower than a text user interface? A command-line interface.

Was there any way I could make a role-playing game fit in the shell?

** Your file system as a dungeon
This was one of those cases where a restricting form pushes one to get creative. I derived many design decisions  from the choice of the command-line interface[fn:3].

The shell is the /environment/ of command-line programs; the file system gives a sense of /place/. At some point I made the connection and decided that the hero of my game would inhabit the file system, with the working directory as its current location. Changing directories would be like moving between dungeon levels, enemies popping up along the way: the more nested the directory, the tougher the enemies. As in roguelikes and other early CRPGs, the goal of the game would just be to crawl down the dungeon, as deep as possible.

The concept finally clicked when I imagined the program it as a ~cd~ replacement, where you would get random turn-based combats as a side effect of doing your work in the terminal. Going back ~~~ (home) would restore your health and give you the choice to buy equipment and supplies.

#+BEGIN_EXPORT html
<div class="text-center">
 <img src="/assets/img/rpgcli.png" style="max-width:100%; max-height:unset">
</div>
#+END_EXPORT

Having a purely command-line interface meant that the gameplay should be non-interactive. The player could only issue commands in the shell. This was a problem for the traditional turn-based combat I had in mind.

The solution was inspired by /Suikoden 2/, a PlayStation game I had recently finished. In /Suikoden 2,/ you manage a huge list of playable characters (over 100) in parties of up to six members. When enemies pop up in dungeons, having to issue six attacks on each turn, with characters you haven't been using for long, can get tedious. The developers had the good sense to introduce an /autobattle/ button that just issues the basic attack for all characters until the enemy is killed.

So I decided to make this autobattle feature the default for rpg-cli. This /felt right/ to me because I'm a very dull player when it comes to combat. I don't particularly enjoy strategizing, I just default to punch with warriors and spell with wizards, with the occasional healing potion in between, until enemies become tough-enough that they force me to stop and think. So I baked that pattern right into rpg-cli's battle logic: default to attack, unless HP is low and a potion is available. (I later extended this to account for magical classes that attack with spells and need to restore their magical points).

This would obviously remove some player agency (and fun) from the combat. To compensate, the variety in the game and the opportunity to strategize would need to take place in between battles: deciding whether to go further down the dungeon or back home to recover, when to use items, how to spend the gold, etc.

Lastly, making my game a CLI program gave an me an opportunity to try Rust, something I had been looking for.

** Research

I felt that the radical simplicity I started from had unexpectedly led me to an interesting concept, so I decided to double down on doing "the simplest thing that could possibly work", extending this mantra to the entire project, not just the interface.

I had a concept, an implementation language, a scope and a rough outline of the interface for my program. But before I could start coding its most basic building blocks I needed to figure out some details about the RPG model: a stat system to know what attributes to put in my ~Character~ struct, a leveling system to know how to raise them, and a combat routine driven by them.

My experience of the genre was almost exclusively through JRPGs, so it felt necessary to do some research to see if I could get inspiration from western video games and tabletop RPGs: did someone else already figured out the minimal necessary stats to make an RPG work? is there a canonical set of enemy classes? Would I benefit from learning the DnD rules?

I started by looking around for tabletop RPGs that made a point their minimalism or genericity:
  - [[https://en.wikipedia.org/wiki/GURPS][GURPS]], the Generic Universal RolePlaying System.
  - [[https://en.wikipedia.org/wiki/TWERPS][TWERPS]], the World's Easiest Role-Playing System.
  - [[https://en.wikipedia.org/wiki/Dinky_Dungeons][Dinky Dungeons]], the smallest role-playing game ever produced (see its [[http://dinkydungeons.com/history.asp][history]] and [[http://dinkydungeons.com/origrules.asp][rules]]).
  - [[http://www.campaignmastery.com/blog/introducing-the-sixes-system/][The Sixes System]], a Minimalist Universal RPG.
  - [[https://www.perilplanet.com/freeform-universal/][FU]], the Freeform Universal RPG.
  - [[https://www.stargazergames.eu/warrior-rogue-mage/][Warrior, Rogue & Mage]], a simple, lightweight role-playing game.

#+BEGIN_EXPORT html
<div class="text-center">
 <img src="/assets/img/dinky.jpg" style="max-width:100%; max-height:unset">
</div>
#+END_EXPORT


Fun and educational as this excursion was, it left me more confused than when I started. I concluded that tabletop rulesets would contribute complexity rather than simplicity to my project, so I went back to video games for reference. Other than the JRPGS I was already familiar with, I spent some time reading about rogue and its descendants; from the little I knew about the genre, it sounded like I could learn a few things about its minimalist design:
  - [[https://web.archive.org/web/20050206091120/http://www.wichman.org/roguehistory.html][A Brief History of "Rogue"]].
  - [[https://insight.ieeeusa.org/articles/going-rogue-a-brief-history-of-the-computerized-dungeon-crawl/][Going Rogue: A Brief History of the Computerized Dungeon Crawl]].
  - [[http://crpgaddict.blogspot.com/2010/02/rogue-most-difficult-crpg-ive-played.html][Rogue: the most difficult CRPG I've played]].
  - [[http://crpgaddict.blogspot.com/2010/02/rogue-story-and-gameplay.html][Rogue: Story and Gameplay]].
  - [[https://gamedevelopment.tutsplus.com/articles/the-key-design-elements-of-roguelikes--cms-23510][The Key Design Elements of Roguelikes]].

Finally, I looked for some RPG design resources. The most useful were the [[https://howtomakeanrpg.com/][How To Make an RPG]] articles, particularly those about [[http://howtomakeanrpg.com/a/how-to-make-an-rpg-stats.html][stats]] and [[http://howtomakeanrpg.com/a/how-to-make-an-rpg-levels.html][levels]].

** Historical digression
I didn't it know at the time, but there's an illustrious tradition of deconstructing the role-playing game.


- crpgs <- tabletop <- commercial war games <- military training war games
- war games and it's descendants <can have hardcore complexity> which is part of the appeal, at least for a segment of the players
- but where there's complexity, there's simplifying potential, room for abstractions
- <it's no secret that there was some overlap between tabletop RPG players and computer programmers. Most importantly, a non trivial portion of the few people with computer access in the late \'70s were DnD players.
- it didn't require much of a leap to try to combine the two; at first to offload the <adjective> <rpg calculations> to the computer, later to create solo playing experiences in the first computerized RPGs.

- japanese: zelda, dragon quest
- diablo: simplify the crpg ceremony, throwing in some of the procedural fun of roguelikes

- in a sense, it was fair to say that crpgs and jrpgs had already done half of the simplification job for me.

** Design

- Minimal stats

  - I wanted stats to be as obvious as possible. I always found dnd stats confusing from a crpg standpoint
    I also was always put off by the games that make you invest a long time choosing class and race and distributing stat points to build your character. how would I know what character to build if I never played this game.

    minimal that could possibly still make sense
    started with a single on (strength following the TWERPS example), but that was weird because made combat too redundant/predictable
    it made more sense to separate hp and str.
    later added speed to add more variety
    still wass pretty obvious/self-explanatory

  - Health Points or HP
  - Strength
  - Speed

https://github.com/facundoolano/rpg-cli/blob/d4c90252db34a04e9abb7e96623c62d6fe47edfe/src/character.rs#L15-L27
#+begin_src rust
pub struct Character {
    pub name: String,

    pub level: i32,
    pub xp: i32,

    pub max_hp: i32,
    pub current_hp: i32,

    pub strength: i32,
    pub speed: i32,
}
#+end_src

- Generic equipment
  - shop
  - items subcommand
  - generic level-based equipment
  - another simplification was for equipment and items. an rpg standard is the loop: beat monsters, get gold in return, spend in equipment, repeating it with ever-tougher monsters, that give more money and let you buy more powerful items. I decided to streamline this a bit: equipment and healing items would have levels just like the characters, and they become automatically available as the character powers up. You don't get to carry old useless swords, you'll always keep the most powerful one and discard the rest

- from rogue I got the permadeath
  fit well with the dungeon structure
  to make it interesting, I added tombstones, so the items from past lives could be recovered if you went back, deep-enough

** Development
- as I started prototyping, I soon learned that I couldn't control the shell working directory from my program. The solution was for the program state to track its own working directory, and use a shell function to sync to it:
#+begin_src shell
rpg () {
    rpg-cli "$@"
    cd "$(rpg-cli pwd)"
}
#+end_src

The hardcore version would be to overwrite the built-in ~cd~ function, so enemies would pop up as the user changed directories:

#+begin_src sh
cd () {
    rpg-cli cd "$@"
    builtin cd "$(rpg-cli pwd)"
}
#+end_src

Other commands like ~rm~, ~mkdir~, or ~touch~, could be similarly aliased to integrate with the game. <The rpg-cli program would eventually include options and flags so users could <script or put together their preferred gameplay experience in the shell>
https://github.com/facundoolano/rpg-cli/blob/da433ff186ba32e86c386e049b3f68e0b6c7de80/shell/README.md

- once I got the minimal core working, I could use it as a canvas to add more functionality, porting fun features from games I'd played over the years. I did add some embelishments, like status ailments, quests, <stat increasing items --inspired by polkemon>, "stones" that raise a stat, hidden enemies, customizable character classes.

latest Character class looks like this

https://github.com/facundoolano/rpg-cli/blob/da433ff186ba32e86c386e049b3f68e0b6c7de80/src/character/mod.rs#L16-L36
#+begin_src rust
pub struct Character {
    pub class: Class,
    pub level: i32,
    pub xp: i32,

    max_hp: i32,
    pub current_hp: i32,

    max_mp: i32,
    pub current_mp: i32,

    strength: i32,
    speed: i32,

    pub sword: Option<equipment::Equipment>,
    pub shield: Option<equipment::Equipment>,
    pub left_ring: Option<Ring>,
    pub right_ring: Option<Ring>,

    pub status_effect: Option<StatusEffect>,
}
#+end_src

- Here's an excerpt of the [[https://github.com/facundoolano/rpg-cli/blob/f2d37631628461ee192864e464e2088415e3866c/src/character/classes.yaml][classes file]] with some player and enemy classes:

#+begin_src yaml
- name: warrior
  hp: [50, 10]
  strength: [12, 3]
  speed: [11, 2]
  category: player
- name: mage
  hp: [30, 6]
  mp: [10, 4]
  strength: [10, 3]
  speed: [10, 2]
  category: player
- name: rat
  hp: [15, 5]
  strength: [5, 2]
  speed: [16, 2]
  category: common
- name: dragon
  hp: [110, 5]
  strength: [25, 2]
  speed: [8, 2]
  inflicts: [burn, 2]
  category: rare
#+end_src


Below is the full definition of the [[https://github.com/facundoolano/rpg-cli/blob/f2d37631628461ee192864e464e2088415e3866c/src/game.rs#L266-L316][~Game::run_battle~]], the auto-battle routine at the core of the game. In a sense, the rest of the code exists as support to this function. I like that it's reasonably self-explanatory, and a good showcase of the features I incorporated along the way.

#+begin_src rust
/// Runs a turn-based combat between the game's player and the given enemy.
/// The frequency of the turns is determined by the speed stat of each
/// character.
///
/// Some special abilities are enabled by the player's equipped rings:
/// Double-beat, counter-attack and revive.
///
/// Returns Ok(xp gained) if the player wins, or Err(()) if it loses.
fn run_battle(&mut self, enemy: &mut Character) -> Result<i32, character::Dead> {
    // Player's using the revive ring can come back to life at most once per battle
    let mut already_revived = false;

    // These accumulators get increased based on the character's speed:
    // the faster will get more frequent turns.
    let (mut pl_accum, mut en_accum) = (0, 0);
    let mut xp = 0;

    while enemy.current_hp > 0 {
        pl_accum += self.player.speed();
        en_accum += enemy.speed();

        if pl_accum >= en_accum {
            // In some urgent circumstances, it's preferable to use the turn to
            // recover mp or hp than attacking
            if !self.autopotion(enemy) && !self.autoether(enemy) {
                let (new_xp, _) = self.player.attack(enemy);
                xp += new_xp;

                self.player.maybe_double_beat(enemy);
            }

            // Status effects are applied after each turn. The player may die
            // during its own turn because of status ailment damage
            let died = self.player.apply_status_effects();
            already_revived = self.player.maybe_revive(died, already_revived)?;

            pl_accum = -1;
        } else {
            let (_, died) = enemy.attack(&mut self.player);
            already_revived = self.player.maybe_revive(died, already_revived)?;

            self.player.maybe_counter_attack(enemy);

            enemy.apply_status_effects().unwrap_or_default();

            en_accum = -1;
        }
    }

    Ok(xp)
}
#+end_src

** Postscript: A text interface for rpg-cli

the file system integration wasn't core of the project, it was a derivation of wanting to make a game that made sense to be played as a series of CLI commands.

- note that the file system integration is sort of an afterthought, something that makes the project stand out and make it curious, but in the end an optional feature that's not <necessary> for a command-line rpg to be possible.
  - and, in fact, once the novelty of having rpg output thrown at you when you were using your shell passed, you either removed the integration or turned to another more convenient way to play the game if you wanted to get to the end. people ended up scripting to level up and I used custom directory-building functions to be able to get abritrarily-deep dungeons.
  - this also hinted that there could be a similarly structured game without having to deal with the file system at all, which could easily turn out to be an interactive text user interface as is planned for the project in this book

** Notes
[fn:2] Carmack: “Story in a game is like story in a porn movie, he said. “It's expected to be there, but it's not important.” (I don't obviously generally agree with this, I love story driven games, but the point is that you could perfectly make a RPG work as pure mechanics, no story, and that approach fit perfectly the restrictions I imposed myself)

[fn:1] TODO advenjure

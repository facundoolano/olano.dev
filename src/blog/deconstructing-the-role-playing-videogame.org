---
title: Deconstructing the Role-Playing Video Game
date: 2024-07-08 10:54:18
layout: post
lang: en
tags: [projects, ideas, videogames]
draft: true
image: assets/img/rpgcli.png
---
#+OPTIONS: toc:nil num:1
#+LANGUAGE: en

/Following up on my [[a-computing-magazine-anthology][previous post]], today I want to write about an idea for a [[https://github.com/facundoolano/rpg-cli][rpg-cli]] spin-off. rpg-cli is one of my fondest personal projects and I never properly documented its development, so I'll start this post off by doing just that./

#+begin_export html
<h2>Contents</h2>
#+end_export
#+TOC: headlines 3

** The simplest thing that could possibly work

I was a little bored at work. I had the spare time, I could've used a side project. It had been a while since I worked on a video game, and I was having that kind of itch. In the past few years I had finished many classic Japanese RPGs: /Final Fantasy VI/, /Chrono Trigger/, /Suikoden 2/, /Final Fantasy Tactics/. That experience was fresh in my head, so I felt compelled to try experimenting with that genre. But, to stay motivated enough to go through with them, I need personal projects to be short-lived, yielding something somewhat finished after a few month. I wasn't going to embark on a full game development project on my own.


I've played JRPGs long-enough that I don't pay much attention to the characters or the plot anymore; I like the pretty pixels, yes, but most importantly I'm drawn to its underlying systems. Explore the map, visit cities, clear dungeons. Kill monsters, level up, buy equipment. Character stats, turn-based combat, leveling system. To me, classic JRPGs are pure mechanism, a kind of puzzle.

Was there some way of getting the fun out of building such a mechanism---of solving that puzzle---, wrapping it with the minimal amount of functionality, the simplest thing that could possibly pass as a video game? How much could I have peeled off and still gotten an RPG? One answer was obvious: off with the story, the plot, the dialogues[fn:2]. But that wouldn't be enough: the real blocker were the graphics, I needed some way to workaround them <in all their rabbit-holing, yak-shaving glory.>

I had recently seen how /Final Fantasy Tactics/ developers fit most of the standard RPG elements, save the battle sequences, into menus. Could I have done something in that direction?
If it was today, I'd consider building a mini game with PICO-8 or an ASCII roguelike interface. At the time, I considered a trick that had worked for me before: replacing the graphics with text[fn:1]. Except that, you know what's narrower than a text user interface? A command-line interface.

Was there any way I could make a role-playing game fit in the shell?

** Your file system as a dungeon
This was one of those cases where choosing a restricting form fosters creativity. The shell is the /environment/ of command-line programs; the file system gives a sense of /place/. At some point I made the connection and decided that the hero of the game would inhabit the file system, with the working directory as its current location. Changing directories would be like moving between dungeon levels; enemies would pop up along the way: the more nested the directory, the tougher the enemies. As in roguelikes and other early CRPGs, the goal of the game would just be to crawl down the dungeon, as deep as possible.

The game finished clicking sense when I imagined the program it as a `cd` replacement, where you would get random turn-based combats as a side effect of doing your work in the terminal. Going back ~~~ (home) would restore your health and give you the choice to buy equipment and supplies.

#+BEGIN_EXPORT html
<div class="text-center">
 <img src="/assets/img/rpgcli.png" style="max-width:100%; max-height:unset">
</div>
#+END_EXPORT

The next thing that I would have to figure out, given the CLI restriction, is how to make combats non-interactive.

- I also don't strategize combats, just punch with warriors and spell with wizards until the enemies get tough enough that they force me to stop an think. could I bake this inclination into the game, as a means to remove interactivity?
  - I'd recently played Suikoden 2, a game with a huge list of playable characters, and a large party of 6. Suikoden 2 actually had a QoL feature which was to just autoplay combats, which was handy for random dungeon encounters where there's no need to think the moves.
  - I decided to make this autocombat the default for rpg-cli. this would remove some of the fun for some of the players, obviously, but not necessarily for me. I could move the decision making out of the combat, which would be turn-based but non-interactive.
  - The actual turns for the player would be each issued CLI command. that way the strategizing would have to be deciding wether to go further down and risk further battles, spend a potion to reduce chances of dying in the next encounter, or going back to recover and buy supplies.

- seemed ideal to tackle as a rust learning project I was looking for




** Research

- I felt that the radical simplicity I started from had unexpectely led me to a good game concept, so I wanted to double down on the "simplest thing that could possibly work" mantra, applying it to the entire project, not just the interface.

- Next up, I needed to think about the underlying RPG system: character stats, leveling system, battle logic.
- <Since my experience of the genre was almost exclusively through JRPGs, it felt necessary to do some research to see if I could get inspiration from western video games and tabletop RPGs.
- Did someone else already figured out the minimal necessary stats to make an RPG work? is there a canonical set of enemy classes? should I learn the DnD rules?

So I first looked around for tabletop RPGs that made a point of being minimalist or generic:
  - [[https://en.wikipedia.org/wiki/GURPS][GURPS]], the Generic Universal RolePlaying System.
  - [[https://en.wikipedia.org/wiki/TWERPS][TWERPS]], the World's Easiest Role-Playing System.
  - [[https://en.wikipedia.org/wiki/Dinky_Dungeons][Dinky Dungeons]], the smallest role-playing game ever produced (see its [[http://dinkydungeons.com/history.asp][history]] and [[http://dinkydungeons.com/origrules.asp][rules]]).
  - [[http://www.campaignmastery.com/blog/introducing-the-sixes-system/][The Sixes System]], a Minimalist Universal RPG.
  - [[https://www.perilplanet.com/freeform-universal/][FU]], the Freeform Universal RPG.
  - [[https://www.stargazergames.eu/warrior-rogue-mage/][Warrior, Rogue & Mage]], a simple, lightweight role-playing game.

#+BEGIN_EXPORT html
<div class="text-center">
 <img src="/assets/img/dinky.jpg" style="max-width:100%; max-height:unset">
</div>
#+END_EXPORT


Fun and educational as this excursion was, I concluded that tabletop rulesets would complicate things rather than simplifying them for my project, so I went back to using on video games as my reference, particularly the JRPGs I was most familiar with. The one exception I made was looking a bit into roguelikes since, from the little I knew about the genre, it sounded like it could have things to offer in terms of minimalist game design:
  - [[https://web.archive.org/web/20050206091120/http://www.wichman.org/roguehistory.html][A Brief History of "Rogue"]].
  - [[https://insight.ieeeusa.org/articles/going-rogue-a-brief-history-of-the-computerized-dungeon-crawl/][Going Rogue: A Brief History of the Computerized Dungeon Crawl]].
  - [[http://crpgaddict.blogspot.com/2010/02/rogue-most-difficult-crpg-ive-played.html][Rogue: the most difficult CRPG I've played]].
  - [[http://crpgaddict.blogspot.com/2010/02/rogue-story-and-gameplay.html][Rogue: Story and Gameplay]].
  - [[https://gamedevelopment.tutsplus.com/articles/the-key-design-elements-of-roguelikes--cms-23510][The Key Design Elements of Roguelikes]].

Finally, I looked for some RPG design resources. The most useful were the [[https://howtomakeanrpg.com/][How To Make an RPG]] articles, particularly those about [[http://howtomakeanrpg.com/a/how-to-make-an-rpg-stats.html][stats]] and [[http://howtomakeanrpg.com/a/how-to-make-an-rpg-levels.html][levels]].

** Historical digression
I didn't it know at the time, but there's an illustrious tradition on deconstructing the role-playing game.

- crpgs <- tabletop <- commercial war games <- military training war games
- war games and it's descendants <can have hardcore complexity> which is part of the appeal, at least for a segment of the players
- but where there's complexity, there's simplifying potential, room for abstractions
- <it's no secret that there was some overlap between tabletop RPG players and computer programmers. Most importantly, a non trivial portion of the few people with computer access in the late \'70s were DnD players.
- it didn't require much of a leap to try to combine the two; at first to offload the <adjective> <rpg calculations> to the computer, later to create solo playing experiences in the first computerized RPGs.

- japanese: zelda, dragon quest
- diablo: simplify the crpg ceremony, throwing in some of the procedural fun of roguelikes

- in a sense, it was fair to say that crpgs and jrpgs had already done half of the simplification job for me.

** Design

*** Minimal stats

- I wanted stats to be as obvious as possible. I always found dnd stats confusing from a crpg standpoint
  I also was always put off by the games that make you invest a long time choosing class and race and distributing stat points to build your character. how would I know what character to build if I never played this game.

  minimal that could possibly still make sense
  started with a single one, but that was weird because made combat too redundant/predictable
  it made more sense to separate hp and str.
  later added speed to add more variety
  still wass pretty obvious/self-explanatory

- Health Points or HP
- Strength
- Speed

later added mp to support the mage class and magic attacks

*** Generic equipment
- shop
- items subcommand
- generic level-based equipment
- another simplification was for equipment and items. an rpg standard is the loop: beat monsters, get gold in return, spend in equipment, repeating it with ever-tougher monsters, that give more money and let you buy more powerful items. I decided to streamline this a bit: equipment and healing items would have levels just like the characters, and they become automatically available as the character powers up. You don't get to carry old useless swords, you'll always keep the most powerful one and discard the rest

*** Permadeath
from rogue
fit well with the dungeon structure
to make it interesting, I added tombstones, so the items from past lives could be recovered if you went back, deep-enough

** Development
*** Working with the shell
- as I started prototyping, I soon learned that I couldn't control the shell working directory from my program. The solution was for the program state to track its own working directory, and use a shell function to sync to it:
#+begin_src shell
rpg () {
    rpg-cli "$@"
    cd "$(rpg-cli pwd)"
}
#+end_src

The hardcore version would be to overwrite the built-in ~cd~ function, so enemies would pop up as the user changed directories:

#+begin_src sh
cd () {
    rpg-cli cd "$@"
    builtin cd "$(rpg-cli pwd)"
}
#+end_src

Other commands like ~rm~, ~mkdir~, or ~touch~, could be similarly aliased to integrate with the game. <The rpg-cli program would eventually include options and flags so users could <script or put together their preferred gameplay experience in the shell>
https://github.com/facundoolano/rpg-cli/blob/da433ff186ba32e86c386e049b3f68e0b6c7de80/shell/README.md

*** Bells and whistles
- once I got the minimal core working, I could use it as a canvas to add more functionality, porting fun features from games I'd played over the years. I did add some embelishments, like status ailments, quests, <stat increasing items --inspired by polkemon>, "stones" that raise a stat, hidden enemies, customizable character classes.
  - (form is liberating)
  - para que esto tenga algún interés, agregar aleatoriedad y alguna posibilidad de toma de decisiones/estrategia: enemigos de distintas clases, esquivar golpes, golpes críticos, equipamiento, ítems, eludir batallas
you don't have a choice in what moves to make in battle, but you decide when to keep going down or returning home, when to use a healing item, what class to use, what equipment to buy first, etc

- permadeath from rogue. +recovering your spoils to make it more interesting

*** Parametric classes

Here's an excerpt of the [[https://github.com/facundoolano/rpg-cli/blob/f2d37631628461ee192864e464e2088415e3866c/src/character/classes.yaml][classes file]] with some player and enemy classes:

#+begin_src yaml
- name: warrior
  hp: [50, 10]
  strength: [12, 3]
  speed: [11, 2]
  category: player
- name: mage
  hp: [30, 6]
  mp: [10, 4]
  strength: [10, 3]
  speed: [10, 2]
  category: player
- name: rat
  hp: [15, 5]
  strength: [5, 2]
  speed: [16, 2]
  category: common
- name: dragon
  hp: [110, 5]
  strength: [25, 2]
  speed: [8, 2]
  inflicts: [burn, 2]
  category: rare
#+end_src

*** Putting it all together

https://github.com/facundoolano/rpg-cli/blob/f2d37631628461ee192864e464e2088415e3866c/src/game.rs#L266-L316

- the Game::run_battle routine is at the core of the mechanism I wanted to reproduce when I set out to work on the project
- in a sense, the rest of the code exists as support for this function
- I also find it, reading it years later, to be very readable and a good showcase of the different features I incorporated

#+begin_src rust
/// Runs a turn-based combat between the game's player and the given enemy.
/// The frequency of the turns is determined by the speed stat of each
/// character.
///
/// Some special abilities are enabled by the player's equipped rings:
/// Double-beat, counter-attack and revive.
///
/// Returns Ok(xp gained) if the player wins, or Err(()) if it loses.
fn run_battle(&mut self, enemy: &mut Character) -> Result<i32, character::Dead> {
    // Player's using the revive ring can come back to life at most once per battle
    let mut already_revived = false;

    // These accumulators get increased based on the character's speed:
    // the faster will get more frequent turns.
    let (mut pl_accum, mut en_accum) = (0, 0);
    let mut xp = 0;

    while enemy.current_hp > 0 {
        pl_accum += self.player.speed();
        en_accum += enemy.speed();

        if pl_accum >= en_accum {
            // In some urgent circumstances, it's preferable to use the turn to
            // recover mp or hp than attacking
            if !self.autopotion(enemy) && !self.autoether(enemy) {
                let (new_xp, _) = self.player.attack(enemy);
                xp += new_xp;

                self.player.maybe_double_beat(enemy);
            }

            // Status effects are applied after each turn. The player may die
            // during its own turn because of status ailment damage
            let died = self.player.apply_status_effects();
            already_revived = self.player.maybe_revive(died, already_revived)?;

            pl_accum = -1;
        } else {
            let (_, died) = enemy.attack(&mut self.player);
            already_revived = self.player.maybe_revive(died, already_revived)?;

            self.player.maybe_counter_attack(enemy);

            enemy.apply_status_effects().unwrap_or_default();

            en_accum = -1;
        }
    }

    Ok(xp)
}
#+end_src

** Postscript: A text interface for rpg-cli

the file system integration wasn't core of the project, it was a derivation of wanting to make a game that made sense to be played as a series of CLI commands.

- note that the file system integration is sort of an afterthought, something that makes the project stand out and make it curious, but in the end an optional feature that's not <necessary> for a command-line rpg to be possible.
  - and, in fact, once the novelty of having rpg output thrown at you when you were using your shell passed, you either removed the integration or turned to another more convenient way to play the game if you wanted to get to the end. people ended up scripting to level up and I used custom directory-building functions to be able to get abritrarily-deep dungeons.
  - this also hinted that there could be a similarly structured game without having to deal with the file system at all, which could easily turn out to be an interactive text user interface as is planned for the project in this book

** Notes
[fn:2] Carmack: “Story in a game is like story in a porn movie, he said. “It's expected to be there, but it's not important.” (I don't obviously generally agree with this, I love story driven games, but the point is that you could perfectly make a RPG work as pure mechanics, no story, and that approach fit perfectly the restrictions I imposed myself)


[fn:1] TODO advenjure

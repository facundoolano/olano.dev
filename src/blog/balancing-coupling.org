---
title: "[tl;dr] Balancing Coupling in Software Design"
date: 2025-10-17 08:29:34
layout: post
lang: en
tags: [software, books, tldr]
refs: [coupling]
draft: true
image: coupling.jpg
---
#+OPTIONS: toc:nil num:nil
#+LANGUAGE: en

#+BEGIN_EXPORT html
<div class="text-center">
 <a href="https://coupling.dev/" target="_blank"> <img src="{{site.config.static_root}}/img/coupling.jpg" width="320"></a>
</div>
#+END_EXPORT

*** Commentary
I got interested in this after reading the [[domain-driven-design-revisited][Domain-Driven Design book]] by the same author, because of the historical perspective he applied to his treatment of modular design. This new book sounded like it would expand on that, and it didn't disappoint: it's well researched, building on the ideas of Parnas, Myers, Brooks, Conway, and Ousterhout, to produce something new and useful. Vlad Khononov does something that [[unit-testing-principles][I find is fundamental]] to the software design discussion: he provides principled definitions to reduce our reliance on gut feeling when we make decisions. That being said, while insightful, it's also a rather specialized book, one that I recommend to software design nerds but not necessarily to every programmer (as, say, I do recommend /A Philosophy of Software Design/). I may change this assessment if I find myself frequently using its heuristics to success.

The thesis of the book: despite it's reputation, coupling is not something fundamentally bad that we need to remove but an attribute that we should manage strategically. Similarly to essential complexity, a useful software system can't exist without some form of coupling of its components. An easy way to internalize this idea is remembering that /cohesion/ is sometimes defined as /good coupling/.

Software has a fractal nature, one can reason about modularity at the system, service, namespace, class, and function level. At each level there are interfaces and implementation, module depth and complexity. Complexity is twofold: local and global. And since software is fractal, this level's local global complexity becomes a higher level's local one. Naively splitting modules into smaller ones just pushes local complexity up, making the overall system more complicated. Our job then is not chasing local minima but striking a balance: a good enough trade off that reduces the maintenance costs.

The first half of the book is spent on definitions: the usual suspects (complexity, modularity, coupling), some historically relevant concepts (structured design's module coupling, connasence), and a few new ones introduced by the author (integration strength, distance, volatility). These are used to compose heuristics (represented as formulas) to asses the modularity and /balance/ of components in a system, to detect problems and hint at possible solutions. This activity is what the author calls balancing (and re-balancing) coupling.

To a large extent, the process can be summarized as: if modules are strongly integrated (they share much knowledge), reduce their distance; if they are weakly integrated (they don't share much knowledge), increase their distance. Notice how this differs from the notion that smaller, more spread apart components necessarily yield simpler systems (a notion that leads to microservice hell and left-pad).

But the balancing is not limited to "moving things around". Given that software systems are fractal networks, one can introduce new levels of abstraction to allow them to grow beyond their structural limits---and the cognitive load its maintainers can support. This is one of the strengths of the theory presented by the book: the same principles apply at all levels of a system; there's no hard distinction between software design and architecture---not even between software systems and [[a-note-on-essential-complexity][the human systems they integrate]]---just different scales, different semantic levels: different perspectives.




*** Summary

---
title: My Software Bookshelf
date: 2024-08-21
layout: post
lang: en
tags: [software, books, memoirs]
draft: true
---
#+OPTIONS: toc:nil num:nil
#+LANGUAGE: en

Here are books I have read twice \\
and books I expect to read again in time.\\
Here are books I hope I'll read\\
and books I wish I had but never will.

#+BEGIN_EXPORT html
<br/>
<div></div>
#+END_EXPORT

Some of these are not for reading\\
but for holding up and smelling and feeling;\\
some of these are just for skimming:\\
starting out---just staring---and leaving.
#+BEGIN_EXPORT html
<br/>
<div></div>
#+END_EXPORT

Have a list.

-----
1. Code[fn:1]
   + The New Turing Omnibus[fn:2]
2. The Innovators[fn:3]
   + The Mythical Man Month[fn:4]
   + The Soul of a New Machine[fn:5]
   + Coders at Work[fn:6]
3. The Algorithm Design Manual[fn:7]
   + Programming Pearls[fn:8]
4. The Missing README[fn:9]
5. On Writing Well[fn:10]
   + Several short sentences about writing[fn:11]
6. Concepts, Techniques, and Models of Computer Programming[fn:12]
   + Exercises in Programming Style[fn:13]
7. The Pragmatic Programmer[fn:14]
8. The Design of Everyday Things[fn:15]
9. A Philosophy of Software Design[fn:16]
10. How Linux Works[fn:17]
    + Systems Performance[fn:18]
11. Learn You Some Erlang for Great Good![fn:19]
    + Learn Concurrent Programming with Go[fn:20]
12. SQL Performance Explained[fn:21]
13. Designing Secure Software[fn:22]
    + Real-World Cryptography[fn:23]
14. Release It![fn:24]
15. Kill It With Fire[fn:25]
16. The Staff Engineer's Path[fn:26]
    + The Manager's Path[fn:27]
    + Team Topologies[fn:28]
    + Fundamentals of Software Architecture[fn:29]
    + Building Microservices[fn:30]
17. Designing Data-Intensive Applications[fn:31]
    + Distributed Systems for Fun and Profit[fn:32]
    + Database Internals[fn:33]
18. Crafting Interpreters[fn:34]
    + Essentials of Compilation[fn:35]

-----

[fn:1] Back in college, I learned about circuits at a physics class. I learned about boolean algebra at a math class; binary code at a programming class; logic gates and CPU architecture at an electronics class, and information theory at a data organization class. Some of these courses were years apart from each other. I always felt I was missing the big picture, an unifying thread to tie all this disparate knowledge together. I wish I had a book like /Code/ to follow along back then. Not only does it walk the computer from its lowest to its highest level of abstraction, but it throws in a lot of historical context along the way. /Code/ is compact and interesting enough that I frequently take it out and plan to read it cover to cover, just out of curiosity and entertainment, even all these years after first learning about its material.

[fn:2] After skimming its contents, I couldn't resist buying /The New Turing Omnibus/, nor adding it to this list. There is some overlap with /Code/ but, if knowledge in /Code/ was stacked chapter by chapter, this book is a bag of loosely connected topics, forming a wide sample of Computer Science. The treatment isn't superficial but the structure makes it better at sparking curiosity than as means to master its content. /The New Turing Omnibus/ is a book I would recommend to scientists and engineers to get a taste of Computer Science; a book I would have recommended to myself, when I was starting out, to get excited about all the places my career could take me; a book that could sit on the coffee table of mad man or casually shuffle the thoughts of a software engineer.

[fn:3] /The Innovators/ does with computing what /Fermat's Last Theorem/ did with mathematics, /The Age of Uncertainty/ with physics, /Replay/ with video games and /It's all a Game/ with board games: it tells the history of a field like a thriller. Every other book in this list has a place in the timeline that /The Innovators/ lays out.

[fn:4] The Mythical Man Month

[fn:5] Have you ever been part of a highly-motivated, self-absorbed engineering team? Have you lost
your sleep and put everything you've got into a project, and forgot the point of it all but just kept going, out of respect for your teammates? Now imagine one of those teams, back in the \'70s, during the minicomputer era, before PCs and the internet, before most people had even seen a computer---let alone use one. And imagine there's a professional journalist sitting in with the team, documenting the whole process, trying to capture that trance the engineers seem to get into, trying to explain to himself what is it about the stuff that makes them care almost to the point of self-destruction. That's /The Soul of a New Machine/.

[fn:6] The interview is such an entertaining literary form, I wonder why it isn't frequented in our field. Is it naive to think that it's because the idea of the genius hacker has gone out of fashion, in favor of the competent team? Or are the rockstar CEOs now hogging all the spotlight? Or, perhaps, we're all so self absorbed now that we can only think of writing in the first person. In any case, there's a lot to like about /Coders at Work/, even if it has become a history book as much as a book about the craft. I'll name three things that I thank it for: it introduced me to [[https://en.wikipedia.org/wiki/The_Paris_Review#Interviews][The Paris Review interviews]]; it pushed me to finally try Emacs---which I continue to use to this day---; it provided me with indisputable proof that there's no single right way of programming. In this sample you'll read about those that favor team work and those that prefer working alone; proponents of bottom-up or top-down or middle out; some that skip comments and some that do literate programming; some that start polishing abstract interfaces and others that shove everything in a single file. All of them were successful, all of them are exemplar.

[fn:7] One of my biggest sources of imposter syndrome is that I never had to struggle with an algorithms textbook when I was at college. The teachers of the algorithms and data structures course were young and too eager to jump from abstract data types to object-oriented programming---which was the topic of another course. Years later I read the Aho/Hopcroft/Ullman book on my own, but I guess reading these things isn't of much use if you don't bother with doing the exercises. The industry's tendency to use puzzle-solving skills as a proxy for developer competence isn't helping, either. I chose to add the Skiena book to my shelves because its structure makes it look more approachable than the alternatives: 300 hundred pages to cover the fundamentals, favoring war stories over demonstrations, and a catalog of algorithmic problems to wrap it up. I sincerely want to read this thing, I swear, it's just life---and other books in this list---keep getting in the way.

[fn:8] I like how /Programming Pearls/ takes what could be the syllabus of a Computer Science class and gives it a craftsman's treatment. It's not so much about the specific techniques but about the problem-solving mindset you need to get into use them, and the creativity of devising your own. It's also, as its title suggests, about these little jewels that don't make your every day work but that, when you come across them, remind you why you fell in love with this thing.

[fn:9] I had the privilege of getting a full-time job at a software company right after starting college. That certainly delayed my graduation but, in exchange, it armed me with perspective for the rest of my career: I would take both what I saw in class and at the office with a grain of salt. I remember, from those first couple of years, being overwhelmed by the amount of things that I so obviously didn't know. It was hard to prioritize, to tell what was important to really understand, what I just needed to get familiar with, and what I could just ignore. I think that /The Missing README/ would have been a life saver back then. Project management methodologies are the perfect example: chapter 12 and the [[https://agilemanifesto.org/][Agile Manifesto]] should be all you need; beware of whoever says otherwise---they may be trying to make you to join their cult.

[fn:10] Text is the stuff of programming. Writing is an important skill, even when only applied to READMEs and PR descriptions. Strunk & White's /Elements of Style/ is the standard recommendation, but I find it too low level, too focused on preventing errors that can be detected by a computer. If, as suggested in /The Pragmatic Programmer/, we treat English as just another programming language then /Elements of Style/ deals with syntax and /On Writing Well/ deals with design. This book will push you to be deliberate about the many little choices involved in composing a nonfiction text; it will make you think about how to start and how to finish, who your audience is---what can you expect them to know, what do you need to supply, what will the text say to them. It will show you that, much like programming, writing is about simplifying, clarifying, tidying up and fixing what has already been written.

[fn:11] /Several short sentences about writing/ is an advanced book. I don't mean it's dense or hard to read. On the contrary, it's a light read, in the good sense of the word: ethereal. A book that doesn't tire the eye, that flows like poetry. (That's a compliment). (And I don't read poetry). /Several short sentences about wiring/ is an advanced book because it took me a decade to be in a position to appreciate why its discussion is relevant for a software engineer. I needed to first acknowledge that /programs must be written for people to read, and only incidentally for machines to execute/, that /English is just another programming language/, that /we're in the human communication business/, that programming is a form of writing.

[fn:12] In college and at the office, I was exposed to a very one-sided view of programming: C was powerful but problematic; C++ solved some of its problems but added new ones; Java fixed C and C++ and was pretty much /The End of History/ when it came to programming languages. Being a good software developer largely meant getting good at Java's flavor of Object-Oriented Programming. I was suspicious of this mindset; after all, every useful program in my computer was written in C or C++. I became a dissident after teaching myself Python one summer, and a full on heretic later that year, after taking a Programming Languages seminar. The first part of the semester followed the /Concepts, Techniques, and Models of Computer Programming/ book, building every major paradigm onto a subset of the Oz language. I wasn't yet equipped to tell the difference between easy and simple but, awkward as the Oz syntax felt, it was obvious how objects complicated the declarative model and how shared state was trickier than message passing. For the second part of the course we had to research a programming language. I chose Erlang because I was curious about functional programming and its famous concurrency model but, most of all, because of its telecomm roots---this was a platform designed to solve real-world engineering problems. Little did I know that, almost a decade later, I would get the chance to use this weird Scandinavian language professionally and that it would shape the way I reason about software.

[fn:13] As you may have by now guessed, I have a soft spot for constraints-based writing. The /urtext/ of creative constraints is Raymond Queneau's /Exercises in Style/, where he tells the same trivial story 99 times using different literary forms. Cristina Videira Lopes brings this idea to the software world by solving the same programming problem in different coding styles. The result is not only entertaining but an elegant way to structure a discussion of language paradigms and computing history. I think there were some missed opportunities in the styles selection, and I'm still not sure about the choice of Python to implement the solutions, but the concept alone makes this book nothing short of genius.

[fn:14] /The Pragmatic Programmer/ is a catalog of principles and practices across the discipline and, as such, the discussion remains superficial. Many of its topics could be fill its own book. And, yet, there's value in going through this wide overview, item by item; seeing the authors approach different problems in different contexts distills that pragmatic attitude that is the theme of the book. /The Pragmatic Programmer/ is one of my favorite software books. I read the first edition as I was starting out and the 20th anniversary one as a senior engineer. Some of its advice---/be a catalyst for change/, /don't live with broken windows/, /delight users, don't just deliver code/---resounded like a mantra throughout my career.

[fn:15] < (The Design of Everyday Things). I'm ashamed to admit...

[fn:16] /A Philosophy of Software Design/ is my /I Ching/. When I first read it, I had been working as a professional programmer for over a decade. I thought I had a good idea of how to write code, of what a good design was, even if I couldn't quite put it to words. And then this little and absurdly unassuming book made me change my mind about things I'd previously thought were obvious---/smaller modules are always better/, /inline comments are a bad smell/, etc. With his definitions, Ousterhout removes some of the subjectivity from notions like /complexity/ and /abstraction/, and offers many heuristics along with examples of how they stop making sense when taking too far. Perhaps the book's biggest contribution is the idea of /module depth/ and the advice to strive for modules that are not small or large but deep.

[fn:17] I could try to fool myself into thinking someday I'll read [[https://pages.cs.wisc.edu/~remzi/OSTEP/][/Operating Systems: Three Easy Pieces/]], but that day would never come. Instead, I've picked up---and I'm currently half-way through---the humbler /How Linux Works/, a concrete and up to date book about the only Operating System I will ever care to really learn about. If it could only have 10% or 20% more conceptual background it would be just perfect, thank you.

[fn:18]  Who isn't guilty of throwing the "root of all evils" bit around at some point? I am, but these days I feel better represented by Joe Armstrong's quote than by Knuth's: /Make it work, then make it beautiful, then if you really, really have to, make it fast. 90% of the time, if you make it beautiful, it will already be fast. So really, just make it beautiful!/ /Systems Performance/ is for the other 10% of the time. The /Performance Analysis Methodology/ [[https://www.youtube.com/watch?v=abLan0aXJkw][talk]] and [[https://queue.acm.org/detail.cfm?id=2413037][paper]] are a good introduction to the ideas in the book; the [[https://netflixtechblog.com/linux-performance-analysis-in-60-000-milliseconds-accc10403c55?gi=7992fad4b27b][/Linux Performance Analysis in 60,000 milliseconds/]] is the practical tl;dr. When that fails, then there's /Systems Performance/, which is probably the most technical and specialized book in this list---and my bookshelf.
I learned about Brendan Gregg's work through a colleague, during a period when management at my company was fixated on reducing infrastructure costs by making us optimize our systems. The book forced me to work against my instincts, looking inside of the very things my brain insisted on abstract away. I was out of my league, clearly, and I didn't save any infra costs, but I came out a better engineer from that process.

[fn:19] The Erlang language and its platform are so special---the pragmatic take on functional programming, the actor concurrency model, the /let it crash/ philosophy, the preemptive scheduler, the OTP behaviors, the built-in observability tools---that it's worth studying just for the perspective and inspiration it can provide. And I can't think of a better way to study it than reading /Learn You Some Erlang for Great Good!/---except perhaps running an Erlang system in production /while reading it/. It's also one of the best software books I know; beyond Erlang, it can be a fun introduction to systems design, fault tolerance and distributed systems.

[fn:20] Concurrent programming is hard for many reasons. We tend to think sequentially. Concurrent programs are harder to test and their bugs harder to reproduce. We only need to write concurrent code occasionally. But, also, I think the narrative of the discipline, and the tooling, hasn't caught up to the last couple of decades of hardware evolution. Why do we spend so many cycles thinking and talking about sophisticated algorithms and distributed architectures, and so few in concurrent program design? Why does the concurrency model feel like an afterthought in most programming languages, old and new? There are two notable exceptions to this trend: the Erlang and the Go ecosystems. Erlang is a superior platform but, paraphrasing its author, you can't get Erlang's concurrency banana without the OTP gorilla holding the banana and the preemptive scheduler jungle. Golang is the general purpose alternative: for the most part you work and think like in any other mainstream language, and when you need concurrency you can rely on message passing with goroutines and channels. And you can always resort to threads and mutexes if necessary. Hence, /Learn Concurrent Programming with Go/.

[fn:21] As I was putting together this list, I noticed something was missing from my bookshelf. There are books touching on data structures, file systems, database internals, software architecture and large-scale distributed data systems. But none deals with using databases from a developer's perspective. Years ago I would have covered that gap with something like /Seven Databases in Seven Weeks/, to get an overview of available implementations and their trade-offs. But, as I grow older and more conservative I tend to favor minimalism and frugality: you're likely to only need PostgreSQL for most projects, why not focus on getting good at that. That still doesn't warrant reading a book entirely dedicated to PostgreSQL, or to the SQL language, or to the relational model, for that matter. Looking around I saw many recommendations of /SQL performance explained/, which has an [[https://use-the-index-luke.com/][online version]]. This book starts with a bold premise: /the only thing developers need to learn is how to index/. Far from turning the book into a shallow tutorial, this premise provides it with structure: each chapter dedicated to a part of an SQL query, but going deep into its inner workings and the data structures that power it.

[fn:22] Designing Secure Software

[fn:23] Real-World Cryptography

[fn:24] The biggest revelation of my professional life was moving from building software wishfully expected to scale, to maintaining systems that had been running in production, for years, at scale.
It wasn't about easing development, it was about easing operations. It wasn't about sophisticated components, it was about keeping things simple to reason about. It wasn't about preventing errors, it was about working in spite of them. It wasn't about scalability, it was about stability. While some of the war stories and the discussion show their age, no book that I know of does a better job at imbuing this production-first attitude than /Release it!/


[fn:25] Kill It With Fire

[fn:26] The Staff Engineer's Path

[fn:27] /We're not in the high-tech business, we're in the human communication business/. That idea alone deserves /Peopleware/ a place in my shelves but, while its insights are still relevant today, a lot of the discussion now feels dated ---from avoiding phone call interruptions to arranging the office cubicles. I think, today, /The Manager's Path/ does a better job at <bringing the human aspects of our activity to the front>. Anyone leading or managing or being managed---that is, anyone---can benefit from the ideas in this book.

[fn:28] Team Topologies

[fn:29] I have mixed feelings about software architecture. I think architecture, the field, is worth studying, discussing, and working on, but the role of the software architect---calling the shots while the devs do the work---shouldn't exist. That's why I think the architectural mindset comes second to the organizational perspective promoted by /The Staff Engineer's Path/ and /Team Topologies/. That being said, /Fundamentals of Software Architecture/ is a great book, packed with practical ideas, techniques, and patterns. The companion /Software Arechitecture: The Hard Parts/ presents the same material through a case study.

[fn:30] <(Building Microservices) this holds a special place for me because it was the first architecture book I've read that seemed to be written <for my own times>. regardless of microservices, it seemed to have answers to the question of how should software be architected in the post cloud world. <I picked it up because I joined a company that was doing microservices and I wanted to do it right. I learned that we shouldn't have been doing it at all.

[fn:31] I picked up /Designing Data-Intensive Applications/ out of a mix of professional curiosity and fear of missing out. I felt that I needed some academic support to navigate the technological explosion that had taken place in the years after I had graduated. Kleppmann hits a surprising balance of depth, breadth, length and readability. I religiously worked my way through the book for a few months. Over the years, I've read accounts from other engineers that went through a similar process---even though none of us are really designing data-intensive applications or using advanced distributed systems techniques in production. I concluded that this book has become a modern classic and reading it is a rite of passage for a certain kind of senior engineer.

[fn:32] /Distributed Systems for Fun and Profit/ is the gentler introduction to distributed systems. Because of its topic selection and the mostly conceptual treatment, it should be all most software developers need to know about this area. And, for those that want more, each chapter wraps with a curated list of follow-up papers and resources.

[fn:33] I you compare the table of contents of /Database Internals/ and /Designing Data-Intensive Applications/ you'll see a lot of overlap. I think of /Database Internals/ as a kind of B-side of Kleppmann's book; more succinct, slightly more focused on databases than in distributed systems. Considering how complex these topics get, this book is a good alternative to reading the other for the second time.

[fn:34] I've seen fads come and go, conventional wisdom emerged and forgotten, but I haven't seen that many universal agreements. One thing everybody seems to agree about: the Dragon Book is the definitive reference on compiler and language design. Another one: the Dragon Book is almost impossible to read. Over the last couple of years I saw a new universal truth emerge: /Crafting Interpreters/ is the book anyone interested in language design should read. So far I've only read the introduction, but just by skimming it and reading about how it was [[https://journal.stuffwithstuff.com/2020/04/05/crafting-crafting-interpreters/][written]] and [[https://journal.stuffwithstuff.com/2021/07/29/640-pages-in-15-months/][diagrammed]], I can tell why this is such a praised and loved book. I wonder if over the next decade we'll see a generation of languages influenced by the work of Bob Nystrom. I decided to put this by the end of my list; I'd like to replace the idea that compilers are a tricky subject to struggle with in college with this: designing a programming language is what our career has been preparing us for.

[fn:35] I couldn't wrap this up without a single mention of Lisp. There are books in my shelves about learning to program with Lisp---about thinking in Lisp---; a book to learn Clojure and another to master it; a book to configure my editor using a Lisp dialect, and another to learn how computers learn, using Lisp. But nothing suits Lisp, and Racket in particular, like language development. I don't remember where I learned about /Essentials of Compilation/---it's not a very popular book judging by the amount of reviews I can find online. But it seems approachable, building on the ideas of the [[https://legacy.cs.indiana.edu/~dyb/pubs/nano-jfp.pdf][nanopass framework]] and the [[http://scheme2006.cs.uchicago.edu/11-ghuloum.pdf][incremental approach]] to compiler construction; a good complement to /Crafting Interpreters/, and the perfect excuse to go nuts on Lisp.

-----

See also:

- [[https://github.com/facundoolano/software-papers][Papers for Software Engineers]].
- [[https://teachyourselfcs.com/][Teach Yourself Computer Science]].
- [[https://blog.codinghorror.com/recommended-reading-for-developers/][Recommended Reading for Developers]].

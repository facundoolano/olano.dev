---
title: My Software Bookshelf
date: 2024-08-21
layout: post
lang: en
tags: [software, books]
draft: true
---
#+OPTIONS: toc:nil num:nil
#+LANGUAGE: en

Here are books I have read twice \\
and books I expect to read again in time.\\
Here are books I hope I'll read\\
and books I wish I had but never will.

#+BEGIN_EXPORT html
<br/>
<div></div>
#+END_EXPORT

Some of these are not for reading\\
but for holding up and smelling and feeling;\\
some of these are just for skimming:\\
starting out---just staring---and leaving.
#+BEGIN_EXPORT html
<br/>
<div></div>
#+END_EXPORT

Have a list.

-----
1. Code[fn:1]
2. The Innovators[fn:2]
   + The Mythical Man Month[fn:3]
   + Coders at Work [fn:4]
   + The Soul of a New Machine[fn:5]
3. The Algorithm Design Manual[fn:6]
   + Programming Pearls[fn:7]
4. The New Turing Omnibus[fn:8]
5. Concepts, Techniques, and Models of Computer Programming[fn:9]
   + Excercises in Programming Style[fn:10]
6. The Missing README[fn:11]
7. On Writing Well[fn:12]
   + Several short sentences about writing[fn:13]
8. The Design of Everyday Things[fn:14]
9. Thinking in Systems[fn:15]
10. The Pragmatic Programmer[fn:16]
11. A Philosophy of Software Design[fn:17]
    + Learning Domain-Driven Design[fn:18]
12. How Linux Works[fn:19]
    + Systems Performance[fn:20]
13. Learn Concurrent Programming with Go[fn:21]
    + Learn You Some Erlang for Great Good![fn:22]
14. SQL Performance Explained[fn:23]
15. Designing Secure Software[fn:24]
    + Real-World Cryptography[fn:25]
16. Release It![fn:26]
17. Kill It With Fire[fn:27]
18. The Staff Engineer's Path[fn:28]
    + The Manager's Path[fn:29]
    + Team Topologies[fn:30]
    + Fundamentals of Software Architecture[fn:31]
    + Building Microservices[fn:32]
19. Crafting Interpreters[fn:33]
    + Essentials of Compilation[fn:34]
20. Designing Data-Intensive Applications[fn:35]
    + Distributed Systems for Fun and Profit[fn:36]
    + Database Internals[fn:37]

-----

[fn:1] Back in college, I learned about circuits at a physics class. I learned about boolean algebra at a math class; binary code at a programming class; logic gates and CPU architecture at an electronics class, and information theory at a data organization class. Some of these courses were years apart from each other. I always felt I was missing the big picture, an unifying thread to tie all this disparate knowledge together. I wish I had a book like /Code/ to follow along back then. Not only does it walks the computer from its lowest to its highest level of abstraction, but it throws in a lot of historical context along the way too. /Code/ is compact and interesting enough that I frequently take it out and plan to read cover to cover, just out of curiosity and entertainment, even all these years after first learning about its material.

[fn:2] <One of those books that tell the history of a field like a thriller. This does with computing what /Fermat's Last Theorem/ did with mathematics, /The Age of Uncertainty/ with physics, /Replay/ with video games and /It's all a Game/ with board games. Such an historical overview provides a great framework to organize the knowledge of a discipline.

[fn:3] <Perhaps the first book to qualify as a Software Engineering classic. Any engineer would probably get something out of /The Mythical Man Month/ and /No Silver Bullet/, but the collection as a whole by now seems more of historical than practical interest.

[fn:4] TODO coders at work.

[fn:5] The Soul of a New Machine

[fn:6] The Algorithm Design Manual

[fn:7] Programming Pearls

[fn:8] The New Turing Omnibus

[fn:9] Concepts, Techniques, and Models of Computer Programming

[fn:10] Excercises in Programming Style

[fn:11] The Missing readme

[fn:12] writing well

[fn:13] Several short sentences about writing

[fn:14] The Design of Everyday Things

[fn:15] Thinking in Systems

[fn:16] The Pragmatic Programmer

[fn:17]  A Philosophy of Software Design

[fn:18]  Learning Domain-Driven Design

[fn:19]  How Linux Works

[fn:20]  Systems Performance

[fn:21]  Learn Concurrent Programming with Go

[fn:22] Learn You Some Erlang for Great Good!

[fn:23] As I was putting together this list, I noticed something was missing from my bookshelf. There are books touching on data structures, file systems, database internals, software architecture and large-scale distributed data systems. But none deals with using databases from a developer's perspective. Years ago I would have covered that gap with something like /Seven Databases in Seven Weeks/, to get an overview of available implementations and their trade-offs. But, as I grow older and more conservative I tend to favor minimalism and frugality: you're likely to only need PostgreSQL for most projects, why not focus on getting good at that. That still doesn't warrant reading a book entirely dedicated to PostgreSQL, or to the SQL language, or to the relational model, for that matter. Looking around I saw many recommendations of /SQL performance explained/, which has an [[https://use-the-index-luke.com/][online version]]. This book starts with a bold premise: /the only thing developers need to learn is how to index/. Far from turning the book into a shallow tutorial, this premise provides it with structure: each chapter dedicated to a part of an SQL query, but going deep into its inner workings and the data structures that power it.

[fn:24] Designing Secure Software

[fn:25] Real-World Cryptography

[fn:26] Release It!

[fn:27] Kill It With Fire

[fn:28] The Staff Engineer's Path

[fn:29] The Manager's Path

[fn:30] Team Topologies

[fn:31] Fundamentals of Software Architecture

[fn:32] Building Microservices

[fn:33] Crafting Interpreters

[fn:34] Essentials of Compilation

[fn:35] Designing Data-Intensive Applications

[fn:36] Distributed Systems for Fun and Profit

[fn:37] Database Internals

---
title: "[tl;dr] Balancing Coupling in Software Design"
date: 2025-10-17 08:29:34
layout: post
lang: en
tags: [software, books, tldr]
refs: [coupling]
draft: true
image: coupling.jpg
---
#+OPTIONS: toc:nil num:nil
#+LANGUAGE: en

#+BEGIN_EXPORT html
<div class="text-center">
 <a href="https://coupling.dev/" target="_blank"> <img src="{{site.config.static_root}}/img/coupling.jpg" width="320"></a>
</div>
#+END_EXPORT

*** Commentary
I got interested in this book after reading [[domain-driven-design-revisited][Learning Domain-Driven Design]] by the same author, specifically after seeing the historical perspective he applied when discussing modular design in the context of microservices. This new book didn't disappoint: it's well researched, building on the ideas of Parnas, Myers, Brooks, Conway, and Ousterhout to bring something new and applicable. Vlad Khononov does something that [[unit-testing-principles][I find is fundamental]]: to provide principled definitions that reduce our reliance on subjectivity and instinct when making software design decisions. That being said, while insightful, it's also a rather specialized book, one that I recommend to software design nerds but not necessarily to every programmer (as, say, /A Philosophy of Software Design/). (I may change this assessment if I find myself frequently using its heuristics to success).

The thesis of the book is: despite it's reputation, coupling is not something fundamentally bad that we need to remove but an attribute that we should manage strategically. Similarly to essential complexity, a useful software system can't exist without some form of coupling of it's components. An easy way to internalize this idea is remembering that /cohesion/ is sometimes defined as /good coupling/.

Software has a fractal nature: one can reason about modularity at the system, service, namespace, class, and function level. At each level there are interfaces and implementation, module depth and complexity. Complexity is twofold: local and global. And since software is fractal, this level's local global complexity becomes a higher level's local one. Naively splitting modules into smaller ones just reduces local complexity by making the overall system more complicated. So our job is not chasing local minima but striking a balance: a good enough trade off that reduces the overall maintenance cost.

The first half of the book is spent on definitions: the usual suspects (complexity, modularity, coupling), some historically relevant concepts (structure design's module coupling, connasence), and a few new ones introduced by the author (integration strength, distance, volatility). These are then used to compose heuristics (represented as formulas) to asses the modularity and /balance/ of components in a system, to detect problems and hint at possible solutions. This activity is what the author calls balancing (and re-balancing) coupling.

To a large extent, the process can be summarized as: if modules are strongly integrated (they share much knowledge), reduce their distance; if they are weakly integrated (they don't share much knowledge), increase their distance. Notice how this differs from the notion that smaller components more spread apart necessarily yield simpler systems (a notion that leads to microservice hell and left-pad). On the contrary, putting things closer together is a valid tool to strike a balance of local and global complexity.

But the balancing is not limited to "moving things around". Given that software systems are fractal networks, one can introduce new levels of abstraction to allow them to grow beyond their structural limits---and the cognitive load its maintainers can support. This is one of the strengths of the theory presented by the book: the same principles apply at all levels of a system; there's no hard distinction between software design and architecture---not even between software systems and [[a-note-on-essential-complexity][the human systems they integrate]]---just different scales, different semantic levels: different perspectives.




*** Summary

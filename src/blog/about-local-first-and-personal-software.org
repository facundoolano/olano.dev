---
title: Software Possession for Personal Use
date: 2024-08-12
layout: post
lang: en
tags: [software]
draft: true
image: assets/img/pc.jpg
---
#+OPTIONS: toc:nil num:nil
#+LANGUAGE: en

There's a lot to be frustrated about contemporary software and the modern web. (If you are a software user and you are not frustrated, you can safely skip this article).

There's a lot to be frustrated about software, the cloud, and Big Tech, especially if you've been using computers long enough to remember what the experience used to be like. It was worst, of course, in some ways, more limited and primitive, but much better in others. And that's the thing: we probably didn't notice that we were making this trade-off---not before we were all-in.

We gave up privacy and control in exchange of convenience and information sharing, but we also gave up performance and offline access, and data durability and ownership. There are things we can do now---things we /need/ to do now, like video conferencing and real-time collaboration---that couldn't be done with traditional desktop software. But for the things we /could/ do back then, it's likely that the overall experience has gotten worse, and it seems to be getting worse all the time.

There's a lot to be frustrated about, many problems with contemporary software and many ways to reason about and address them:

- Building [[https://www.inkandswitch.com/local-first/][local-first software]].
- Replacing platforms [[https://knightcolumbia.org/content/protocols-not-platforms-a-technological-approach-to-free-speech][with open protocols]].
- Self-hosting Free and open-source software.
- Using P2P networks, like BitTorrent and the InterPlanetary File System.
- Using Federated networks, like those powered by [[https://en.wikipedia.org/wiki/ActivityPub][ActivityPub]].
- Moving from walled gardens to the [[https://www.jvt.me/posts/2019/10/20/indieweb-talk/][IndieWeb]].
- [[https://maggieappleton.com/home-cooked-software][Home-cooking software]] as bare-foot developers.

(If you aren't already familiar with these ideas, reading about them is probably a better use of your time than reading the rest of this article).

#+BEGIN_CENTER
\lowast{} \lowast{} \lowast{}
#+END_CENTER

The [[https://www.inkandswitch.com/local-first/][local-first software paper]] describes the transition from desktop to the cloud, what we lost along the way, and how we could get it back. It emphasizes real-time collaboration as a distinguishing factor of modern software. The biggest challenge, then, lies in re-imagining applications like Google Docs in a context where there isn't a centralized server acting as a mediator between clients. Hence the need to experiment with decentralized data replication and conflict resolution, and the prominent place that [[https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type][CDRTs]] occupy in this space.

Useful and ground-breaking as it is, when I look back at my personal experience, it wasn't real-time collaboration what drew me to replace desktop applications with cloud platforms. What forced me to "surrender" was that I went from using a single computer at home to using another one at the office, and carrying a third one in my pocket at
all times. Then another one in my TV and another in my reading device. I needed my programs to run on all these devices, and my data available and synchronized everywhere. Even today, When I look at the home screen on my phone, half of what I see are specialized data synchronization apps: Google Drive, Google Keep, Trello, LastPass, Goodreads, Spotify. Even the ones, like Google Docs and Trello, that are intended for team work, I have in my phone just to access the data when I'm away from my laptop. <For me, the real-time collaboration work typically happens in the desktop, in short lived sessions, so I don't mind having to use invasive applications for that.

So I got into platforms because of the device syncing, and that's something they do well. Why do I want out? For all the reasons listed in the local-first paper, yes, but, most of all, because platforms dumb-down my computing experience. I can live with the loss of control and privacy of short-term real-time collaboration sessions. I can live with unnecessary roundtrip latency and mandatory internet connection. But I can't go back to local-only, single-device applications. And I don't want to live in a world where every 6 months I need to add an extra hop to find an album in Spotify, where Google abruptly retires applications I came to rely on, where Microsoft places ads in my task bar, and Amazon acquires companies to let their products, which I use, rot to death.

As a user, I can't become proficient with platforms like I did with traditional desktop applications---and continue to do with local-only open-source software. Not only they can't be tailored to my needs, but I can't  even adjust myself to the capabilities they offer without the risk of them changing unexpectedly, becoming unusable or altogether unavailable. Platforms get in the way of realizing the Creative Computing and Augmented Human Intellect ideals that made me want to become a programmer. We replaced the [[https://www.youtube.com/watch?v=L40B08nWoMk][bicycle for the mind]] with a bunch of brain crutches.


#+BEGIN_CENTER
\lowast{} \lowast{} \lowast{}
#+END_CENTER


In a [[https://www.youtube.com/watch?v=NMq0vncHJvU][recent conference talk]] by Martin Kleppmann, I perceived a slight shift in the local-first narrative, focusing less on real-time collaboration and more on interoperable data synchronization. This is best illustrated by a diagram on the "local-first Endgame" slide:

#+BEGIN_EXPORT html
<div class="text-center">
 <img src="/assets/img/localfirst.jpg">
</div>
#+END_EXPORT

[TODO explain diagram.] This is a future I look forward to; this talk made me even more enthusiastic about the local-first ideas. But there's still a lot of way to go before the community agrees on protocols and vendors start providing sync services, and open-source libraries become available to assist app developers implementing this architecture. I can think of a few short-term experiments in this direction, like building serverless client applications that synchronize their data with [[https://vlcn.io/docs/cr-sqlite/intro][cr-sqlite]] or writing open-source adapter libraries to turn cloud infrastructure from different providers into dumb banks of encrypted data.

<But these are interesting research projects rather than viable means to build applications today.
<not as appealing to explore to me, since I'm not a front end dev, so I wouldn't be a natural extension from the kind of apps I typically build

#+BEGIN_CENTER
\lowast{} \lowast{} \lowast{}
#+END_CENTER

One way to "escape" platforms that works today is running open-source software on commodity servers (or even on home labs). As Kleppmann rightly points out in his talk, this isn't for everyone and it's not a general solution: most people don't have the skills to do system administration and, among those that do, they may prefer to use their time differently. Self-hosting is not a general solution, but is /a/ solution, and some people do amazing things with it.

I can do some degree of sysadmin but it's not something I particularly enjoy. Since, above all, I like to build software, my take on escaping the cloud is to build my own tools. This is even less practical than self-hosting ---no one can possibly build all the software they need--- and for anything I can put together on my free time, there's probably many better open source tools readily available. I still find it's a worthwhile exercise. You may say that /reinterpreting/ the wheel is my hobby.

I recently published a couple of such tools and, when I went to fill their GitHub descriptions in, I wanted to convey the idea that, while these weren't strictly toy projects, they weren't designed as general-purpose tools, intended to support the needs of a broad audience. I both cases I ended up using the word 'personal' to design that intention: /feedi is a personal feed reader/, /jorge is a personal (small + opinionated) site generator/. So I retrospectively started calling these apps /personal software/.

If I had to define it, I'd say personal software is software developed by someone for their own use (perhaps for the use of a handful of people), fit to the particular needs and preferences of its developer, running and providing data access across their devices. In practical terms, this is just a fancy way of saying "dogfooded webapps", but I find that the first formulation offers an interesting framework to drive decisions during development.


#+BEGIN_CENTER
\lowast{} \lowast{} \lowast{}
#+END_CENTER

The software development process is an endless stream of decisions. Each decision involves trade-offs which (ideally) should be weighed according to the context of the project: its goals, the available resources, the desired capabilities of the software being produced[fn:2]. Given the definition above, this is how I "calibrate" the trade-offs for personal software[fn:4]:

- The project scope should be narrow enough to be executed by a single person. More importantly, the cognitive load should be small enough to be carried by one person---the project should fit in one head.
- The system should be operable in local-only or self-hosted setups with minimal effort.
- The application should be accessible from multiple devices.
- Some interface simplicity can be sacrificed in favor of implementation simplicity[fn:3].
- The user experience should satisfy the needs and preferences of the implementer, as opposed to those of some general user (which removes the problem of modeling such user).
- The software doesn't need to solve the problem of its economical sustainability.

Given my current skill set and preferences, to satisfy those requirements I "instantiate" my projects with these defaults:
- The system is structured as a web application, because the [[http://www.catb.org/~esr/writings/taoup/html/ch11s08.html][browser is a universal front end]], allowing the same application to run on desktop and mobile devices.
- The program can also provide a command-line interface for administrative tasks.
- Go as the language, because it's good for implementing servers and CLI programs, and both can be served by a single easy-to-distribute binary. The Go standard library can get you very far without the need of third party dependencies, and its concurrency model makes it easy to implement features like background tasks, that would require additional processes in other environments.
  - In scenarios where it makes sense to sacrifice operational simplicity in favor of implementation simplicity, I can use Python instead.
- SQLite as the database because it's featureful and easy to operate, and personal software rarely needs to scale beyond a single server.
- htmx because it enables rich interfaces without turning the front end into an additional application to design and implement, even without needing to write much JavaScript code.
- Linux on a VPS, because it's cheap and has low operational overhead (as opposed to using containers or AWS infrastructure)[fn:5].


#+BEGIN_CENTER
\lowast{} \lowast{} \lowast{}
#+END_CENTER


Personal software doesnt scale, just like self-hosting doesn't scale, but it's good to remember that it's an option for software developers. It may eventually become an option for amateur tinkerers, too[fn:1].
knowing that you can drop some of the pretensions when you do decide to tackle a side project, not to build your portfolio, not to acquire some skill, but to recover some of the builder joy and the user power of creative computing.


** Notes

[fn:1] See [[https://maggieappleton.com/home-cooked-software][Home-Cooked Software and Barefoot Developers]].

[fn:5] I'm tempted to throw Tailwind CSS, which I haven't tried yet, into the mix, so I can make it: @@html:<b>G</b>o, <b>H</b>tmx, Linux <b>O</b>n a VPS, <b>S</b>QLite, and <b>T</b>ailwind@@, and call it the "GHOST stack".

[fn:4] You can see how I applied this mindset in the [[reclaiming-the-web-with-a-personal-reader][post about feedi]] and in the [[https://jorge.olano.dev/blog/][jorge devlog]].

[fn:3] This makes it different from most professional software projects where long-term maintainability may be of higher priority than short-term velocity. See /The Rise of Worse is Better/ and /A Philosophy of Software Design/ for discussions of interface vs implementation trade-offs.

[fn:2] Much software development pain arguably comes from neglecting this calibration exercise, as if there were absolute definitions for /good/ ---and /good enough/--- software; eg. assuming that all software should be build for extensibility and scalability.

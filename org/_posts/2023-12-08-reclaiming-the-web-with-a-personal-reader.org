#+OPTIONS: toc:nil num:nil
#+LANGUAGE: en
#+BEGIN_EXPORT html
---
layout: post
title: "Reclaiming the Web with a personal reader"
date: 2023-12-08
tags: [software, programaciÃ³n]
lang: en
---
#+END_EXPORT


** Background
Last year I experienced the all too common career burnout. I had a couple of bad projects in a row, yes, but more generally I became disillusioned with the software industry. There was a disconnection between what I used to like about the job, what I was good at, and what the software job market wanted to buy from me (given my experience, my location and the world economy).

I did the usual thing: I slowed down, quit my job, started therapy. I revised my habits: eat better, exercise, meditate. I tried to stay away from programming and software-related reading for a while. Because I didn't like the effect it had on me, but also encouraged by its apparent enshittification, I quit Twitter, the last social media outlet I was still plugged into.

Not working was one thing, but overcoming the productivity mandate ---the feeling that I had to make the best of my time off, that I was "recharging" to make a comeback--- was another. During this detox period I read /How to do Nothing/, a sort of artistic manifesto disguised as a self-help book that deals with some of these issues. The author Jenny Odell mentions Mastodon when discussing alternative online communities. I had heard about Mastodon, had seen some colleagues move over there, but never really looked at it. I thought it was a good time to try it.

#+BEGIN_CENTER
\ast{} \ast{} \ast{}
#+END_CENTER

I noticed a few things after some weeks on Mastodon.

First, it felt refreshing to be back in control of my feed, to receive strictly chronological updates instead of having some middleman watching my moves to sell me stuff.

Second, there were many people going through a similar process as me, one of discomfort with the software industry and the state of the Web. Some of them were [[https://neustadt.fr/essays/the-small-web/][looking back]] at the old times for inspiration: playing with [[https://atthis.link/blog/2021/rss.html][RSS]], Bulletin Board Systems, [[https://hapgood.us/2015/10/17/the-garden-and-the-stream-a-technopastoral/][digital gardens]] and Web rings; some imagined a more [[https://knightcolumbia.org/content/protocols-not-platforms-a-technological-approach-to-free-speech][open]] and [[https://www.jvt.me/posts/2019/10/20/indieweb-talk/][independent]] Web for the future.

Third, not only wasn't I interested in micro-blogging myself, but I didn't care for most of the updates from the people I was following. I realized that I had been using Twitter, and now Mastodon, as an information hub rather than a social network. I was following people to get notified when they blogged on their websites; I was following bots to get content from media and link aggregators. Mastodon wasn't the right tool for that job.

Things really clicked for me when I learned about the IndieWeb movement, particularly their notion of [[https://aaronparecki.com/2018/04/20/46/indieweb-reader-my-new-home-on-the-internet][social readers]]. Trying Mastodon had been nice, but what I needed to reconnect with the good side of the Web was a feed reader, one I could adjust arbitrarily to my preferences. There are plenty of great RSS readers out there, and I did briefly try a few, but this was the perfect excuse for me to get back in touch with software development. I was going to build my own personal reader.

** Goals

*As a user*, I had some ideas of what I was trying to accomplish.

Rather than the email inbox metaphor I've most commonly seen used as RSS reader interfaces, I wanted something that felt like the Twitter or Mastodon home feed. That is: instead of [[https://danq.me/2023/07/29/rss-zero/][a backlog]] to clear every day, I wanted to get [[https://www.oliverburkeman.com/river][a stream]] of interesting articles whenever I opened the app. The feed would include articles from blogs, magazines, news sites and link aggregators, mixed with status updates and notifications from my Mastodon account (I eventually extended it to include my home feeds from Goodreads and Github). The parsing for those sources should be customizable to ensure a consistent look and feel, regardless of what I got back from their RSS feeds or their APIs.

I also knew that I'd eventually need some sort of reader view, like the one in Firefox, to avoid jumping off the app to read, and to skip paywalls and annoying consent popups.

Although I planned to ingest Mastodon updates and links from aggregator sites, I wasn't really interested in implementing a fully-fledged indie reader with "social" features. I didn't really mind opening another tab to comment, nor having my "content" scattered across third party sites.

That's what I started with. But once I had the basic functionality in place, my plan was to drive development by /what felt right/ and /what felt missing/ as a user.
My short-term goal was to answer, as soon as possible, this question: could this eventually become my primary ---even my sole--- source of information on the Web? If not, I'd drop the project right away. Otherwise, I could move onto whatever was missing to realize that vision.

#+BEGIN_CENTER
\ast{} \ast{} \ast{}
#+END_CENTER

*As a developer*, I wanted to test some of the ideas I'd been ruminating on for over a year. Although I hadn't yet formulated it in those terms, I wanted to apply what I expressed in [[file:../2023-11-30-code-is-run-more-than-read][another post]] as ~user > ops > dev~. This meant that, when prioritizing tasks or making design trade-offs, I would choose ease of operation (local setup, server deploys, software updates, etc.) over development convenience. And I would put user experience above everything else.

Since this was going to be an app for personal use and I had no intention on turning it into anything else, putting the user first meant /dogfooding/: putting my user self, my needs, first. Even if I wanted this to eventually be useful to other people, I presumed I had a better chance at achieving it by designing the app ergonomically for me than by aiming to satisfy some ideal user.

It was very important to me that this didn't turn into a learning project or, worse, a portfolio project. This wasn't about productivity, it was about reconnecting with the joy of software development. It was a leisure projectq but the pleasure wouldn't come from /building something/ but from /using something I had built/.

Assuming me as the single target audience meant that I could postpone whatever I didn't need right away (e.g. user authentication), that I could tackle overly specific features early (e.g. send to Kindle support ), that I could assume programming knowledge (e.g. leaving feed parser customization to ad hoc code instead of choosing between a bland generic implementation and a complicated user interface).

** Design

Given that mental framework, I needed to make some early technical decisions.

*** User Interface
Although this was going to be a personal tool, and I wanted it to work on a local-first setup, I knew that if it worked well I'd want to access it from my phone (in addition to my laptop). This meant that I needed to make this a Web application:

- It was the cost-effective way to write a single application that worked in both devices.
- It allowed me to use HTML and CSS, which is the UI technology tool I'm most familiar with.
- It solved syncing between devices by having state stored in the server.

I wanted the Web UI to be somewhat dynamic, but I definitely didn't intend to build a separate front-end application, learn a new front-end framework or reimplement what the browser already offers. Following the [[https://mcfunley.com/choose-boring-technology][boring tech]] and [[https://www.radicalsimpli.city/][radical simplicity]] advice, I looked for server-side rendering libraries. I ended up using a mix of [[https://htmx.org/][htmx]] and its companion [[https://htmx.org/][hyperscript]], which felt like picking up web development where I'd left it off about a decade ago when I moved to the backend.

*** Architecture

Making the app ops-friendly meant not only that I wanted to be easy to deploy on a Unix-like environment but that it was easy to setup locally, with minimal infrastructure, without assuming docker or nix, etc.

A "proper" IndieWeb reader, at least [[https://aaronparecki.com/2018/03/12/17/building-an-indieweb-reader][as described by Aaron Parecki]], would need to be separated in components, each implementing a different protocols (micropub, microsub, webmention, etc.). This setup enforces a separation of concerns between content fetching, parsing, displaying and publishing. But I felt that, in my case, such architecture would complicate development and operations without buying me much as a user. Since I was doing all development myself, I preferred to build a monolithic Web application with sqlite as a database.

In addition to the Web server, I needed some way to periodically poll the feeds for content. The simplest option would have been a cron job, but that seemed inconvenient, at least for the local setup. I'd used task runners like Celery in the past, but that would have required a couple of extra components: another service to run alongside the app and something like Redis to act as a broker.

Could I get away with running background tasks in the same process as the application? That largely depended on the runtime of the language, which brings me to the next section.

*** Programming language

At least from my superficial understanding of it, Go seemed like the best fit for this project: a simple general-purpose language, garbage-collected but fast enough, with a solid concurrency model and, most importantly for my requirements, one that produced easy to deploy binaries. (I later saw the Miniflux authors [[https://miniflux.app/opinionated.html#golang][make a similar case]] for Golang). The big problem was that I'd never written a line of Go, and while I understood it's a fairly accessible language to pick up, I didn't want to lose focus by turning this into a learning project.

Among the languages I was already fluent with, I needed to chose the one I expected to be most productive with, the one that let me build a prototype to decide whether this project was worth pursuing. So I chose Python.

The bad side of using Python was that I had to deal with its environment and dependency quirks, particularly its reliance on the host OS libraries. Additionally, it meant I'd have to get creative if I wanted to avoid extra components for the periodic tasks. (After some research I ended up choosing gevent and [[https://huey.readthedocs.io/en/latest/contrib.html#mini-huey][an extension of the Huey library]] to run them inside the application process). The good side was that I could leverage Python's libraries for HTTP, feed parsing, scraping, and database access.

*** Testing (or lack thereof)
Perhaps the most controversial aspect of the project was that, at least initially, I wouldn't bother writing tests for it. In a sense, it made me feel /dirty/, but I think it was the right call given what I was trying to do.

Unit tests don't work as a design tool for me. While I see the value in TDD, and think everyone should try it at some point, I don't feel it's a general purpose methodology, one that's necessarily applicable to any project by any person. I've found that the point of view enforced by TDD doesn't align well with how I reason about programming tasks.

TDD considerations aside, unit testing didn't seem like a good upfront investment for this project. Given that I was going to experiment, adding, removing and rearranging features, the cost of maintaining the tests outweighed the value they provided. I didn't mind introducing little logic bugs; I was going to use the app myself so I expected that most significant bugs would just surface over time.

In my experience, integration tests are the ones that provide the most value, in terms of confidence that the application works as expected. More so for this project, where the bulk of the work (and the majority of the bugs) came either from interacting with external sources or from the Web user interface. And while I could have caught some bugs earlier and prevented some regressions if I had integration tests, implementing those required an effort (e.g. serving arbitrary RSS feeds locally for testing different scenarios) that just wasn't worth upfront. (Now that the application is stable, though, I would add some integration tests before trying any significant code change).

** Development

There's a kind of zen flow that programmers unblock when they use their software on a daily-basis. I don't mean just testing it but actually experimenting it as an end user. There's no better catalyst for ideas and experimentation, no better prioritization driver than having to face the bugs, annoyances and limitations of an application first-hand.

After some trial and error with different UI layouts and features, I settled on this usage pattern: open the app, scroll down the main feed, pin what I want to read later, favorite what I want to keep for future reference, open what I want to read now.

I tried several Python libraries to extract HTML content, but none worked as well as Firefox's reader view, powered by the [[https://github.com/mozilla/readability][readability]] library. Since it's a JavaScript library, I resigned myself to adding an optional dependency on node.js to support content reading inside my app. (I use the same content extraction logic  when sending articles to my Kindle; readability produces better documents than Amazon's official Chrome extension).

[TODO desktop screenshot]

With the basic functionality in place, a problem became apparent. My feed mixed sources of  varying quality and publication frequency. Even after curating the list of feeds and carefully distributing them in folders, it was hard to get interesting content by just scrolling items in reverse chronological order: occasional blog posts would get buried behind Mastodon toots, magazine features behind daily news articles.

So I started thinking how to make entry sorting "smarter". My reasoning was this: if I only follow sources I'm interested in, I'll usually want to first see content from the ones that publish more sparingly. If a monthly newsletter came out in the last couple of days, that should show up at the top of my feed, before any micro-blogging or daily news items. So I classified sources in "frequency buckets" and sorted the feed to show least frequent buckets first.

[TODO some screenshot?]

Now, the problem was that when infrequent sources /did/ publish, their articles stuck at the top every time I opened the app. For a while I tried trashing or archiving them, but this was a lot of extra work and pulled me in the direction of "clear the inbox" flow that I was trying to avoid.
I wanted the app to do the work for me, by default, so I came up with this: as I scroll down the feed, previous items get marked automatically as "already seen"; the next time I open the app, the seen articles are skipped, so I'm always getting the least frequent /unseen/ content first.

#+BEGIN_CENTER
\ast{} \ast{} \ast{}
#+END_CENTER

For a while I left the app running on a terminal tab in my laptop, and I used it while I worked on it. Once I noticed interesting content showing up in the feed, I setup  a raspberry pi server in my local network, to have a non-development instance running all the time. This, in turn, encouraged me to improve the mobile rendering of the interface, so I could access it from my phone.

[mobile screenshot]

I eventually reached a point where I /missed/ having the app available when I was out, so I decided to deploy it to a VPS. This forced me to finally add the authentication and multi-user support I'd been postponing, and allowed me to give access to with a few friends for beta-testing. (The VPS setup also encouraged me to buy a domain and setup this website, moving me closer to the IndieWeb ideas that inspired me in the first place).

** Conclusion

It took me about 3 months of (relaxed) work to put together my personal feed reader, which I named [[https://github.com/facundoolano/feedi][feedi]]. I can say that I succeeded in reengaging with software development, and also in building something that I like to use myself, every day. Far from a finished product, the project feels more like my Emacs editor config: a perpetually half-broken tool that can nevertheless become second nature, hard to justify from a productivity standpoint but fulfilling because it's built on my own terms.

I've been using feedi as my "front page of the internet" for a few months now.
Beyond convenience, by using a personal reader I'm back in control of the information I consume, actively in the lookout for interesting blogs and magazines, better positioned for discovery and even surprise.

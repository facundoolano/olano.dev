#+OPTIONS: toc:nil num:nil
#+LANGUAGE: en
#+BEGIN_EXPORT html
---
layout: post
title: "Reclaiming the Web with a Personal Reader"
date: 2023-12-08
tags: [software, programaciÃ³n]
lang: en
---
#+END_EXPORT


** Background
Last year I experienced the all-too-common career burnout. I had a couple of bad projects in a row, yes, but more generally I was disillusioned with the software industry. There was a disconnection between what I used to like about the job, what I was good at, and what the job market wanted to buy from me (given my experience, my location and, the world economy).

I did the usual thing: I slowed down, quit my job, started therapy. I revised my habits: eat better, exercise, meditate. I tried to stay away from programming and software-related reading for a while. Because I didn't like the effect it had on me, but also encouraged by its apparent enshittification, I quit Twitter, the last social media outlet I was still plugged into.

Not working was one thing, but overcoming the productivity mandate ---the feeling that I had to make the best of my time off, that I was "recharging" to make a comeback--- was another. During this detox period, I read /How to Do Nothing/, a sort of artistic manifesto disguised as a self-help book that deals with some of these issues. The author Jenny Odell mentions Mastodon when discussing alternative online communities. I had heard about Mastodon, I had seen some colleagues move over there, but never really looked at it. I thought it was a good time to try it.

#+BEGIN_CENTER
\ast{} \ast{} \ast{}
#+END_CENTER

I noticed a few things after some weeks on Mastodon.

First, it felt refreshing to be back in control of my feed, to receive strictly chronological updates instead of having an algorithmic middleman watching my moves to sell me stuff.

Second, many people were going through a similar process as mine, one of discomfort with the software industry and the state of the Web. Some of them were [[https://neustadt.fr/essays/the-small-web/][looking back]] at the old times for inspiration: playing with [[https://atthis.link/blog/2021/rss.html][RSS]], Bulletin Board Systems, [[https://hapgood.us/2015/10/17/the-garden-and-the-stream-a-technopastoral/][digital gardens]], and webrings; some imagined a more [[https://knightcolumbia.org/content/protocols-not-platforms-a-technological-approach-to-free-speech][open]] and [[https://www.jvt.me/posts/2019/10/20/indieweb-talk/][independent]] Web for the future.

Third, not only wasn't I interested in micro-blogging myself, but I didn't care for most of the updates from the people I was following. I realized that I had been using Twitter, and now Mastodon, as an information hub rather than a social network. I was following people to get notified when they blogged on their websites; I was following bots to get content from media, and link aggregators. Mastodon wasn't the right tool for that job.

Things clicked for me when I learned about the IndieWeb movement, particularly their notion of [[https://aaronparecki.com/2018/04/20/46/indieweb-reader-my-new-home-on-the-internet][social readers]]. Trying Mastodon had been nice, but what I needed to reconnect with the good side of the Web was a feed reader, one I could adjust arbitrarily to my preferences. There are plenty of great RSS readers out there, and I did briefly try a few, but I knew this was the perfect excuse for me to get back in touch with software development: I was going to build my own feed reader.

** Goals

*As a user*, I had some ideas of what I was trying to accomplish.

Rather than the email inbox metaphor I've most commonly seen used for RSS reader interfaces, I wanted something that felt like the Twitter or Mastodon home feed. That is: instead of [[https://danq.me/2023/07/29/rss-zero/][a backlog]] to clear every day, I wanted to get [[https://www.oliverburkeman.com/river][a stream]] of interesting content whenever I opened the app. The feed would include articles from blogs, magazines, news sites and link aggregators, mixed with updates from my Mastodon account. (I eventually extended it to include notifications from Goodreads and GitHub). The parsing of those disparate sources should be customizable to ensure a consistent look and feel, independent from the shape of the data the app received.

Although I planned to ingest Mastodon updates and links from aggregator sites, I wasn't interested in implementing the "social" features of a fully-fledged indie reader. I didn't mind opening another tab to comment, nor having my "content" scattered across third-party sites.

That's what I started with but, once I had the basic functionality in place, I planned to drive development by /what felt right/ and /what felt missing/ as a user.
My short-term goal was to answer, as soon as possible, this question: could this eventually become my primary ---even my sole--- source of information on the Web? If not, I'd drop the project right away. Otherwise, I could move on to whatever was missing to realize that vision.

#+BEGIN_CENTER
\ast{} \ast{} \ast{}
#+END_CENTER

*As a developer*, I wanted to test some of the ideas I'd been ruminating on for over a year. Although I hadn't yet formulated it in those terms, I wanted to apply what I expressed in [[file:../2023-11-30-code-is-run-more-than-read][another post]] as ~user > ops > dev~. This meant that, when prioritizing tasks or making design trade-offs, I would choose ease of operation ---local setup, server deploys, software updates, etc.--- over development convenience. And I would put user experience above everything else.

Since this was going to be an app for personal use, and I had no intention of turning it into anything else, putting the user first in this case just meant /dogfooding/: putting my user self, my needs, first. Even if I eventually wanted other people to try the app, I presumed that I had a better chance of making something useful by designing it ergonomically for me, than by trying to satisfy some ideal user. It was very important to me that this didn't turn into a learning project or, worse, a portfolio project. This wasn't about productivity; it was about reconnecting with the joy of software development. The pleasure wouldn't come from /building something/ but from /using something I had built/.

Assuming myself as the single target audience meant that I could postpone whatever I didn't need right away (e.g. user authentication), that I could tackle overly specific features early (e.g. send to Kindle), that I could assume programming knowledge for some scenarios (e.g. leaving feed parser customization to ad hoc code instead of choosing between a bland generic implementation and a complicated user interface).

** Design

Given that mental framework, I needed to make some early technical decisions.

*** User Interface
Although this was going to be a personal tool, and I wanted it to work on a local-first setup, I knew that if it worked well I'd want to access it from my phone (in addition to my laptop). This meant that I needed to make it a Web application:

- It was the cost-effective way to have a single interface work for both devices.
- It allowed me to use HTML and CSS, the UI technology I'm most familiar with.
- It solved device state syncing by having it stored on the server.

I wanted the Web UI to be somewhat dynamic, but I didn't intend to build a separate front-end application, learn a new front-end framework, or re-invent what the browser already offers. Following the [[https://mcfunley.com/choose-boring-technology][boring tech]] and [[https://www.radicalsimpli.city/][radical simplicity]] advice, I looked for server-side rendering libraries. I ended up using a mix of [[https://htmx.org/][htmx]] and its companion [[https://hyperscript.org/][hyperscript]], which felt like picking Web development up where I'd left off over a decade ago.

*** Architecture

Making the app ops-friendly meant not only that I wanted it to be easy to deploy, but easy to set up locally, with minimal infrastructure, without assuming Docker or Nix, etc.

A "proper" IndieWeb reader, at least [[https://aaronparecki.com/2018/03/12/17/building-an-indieweb-reader][as described by Aaron Parecki]], needs to be separated into components, each implementing a different protocol (Micropub, Microsub, Webmentions, etc.). This setup enforces a separation of concerns between content fetching, parsing, displaying, and publishing. I felt that, in my case, such architecture would complicate development and operations without buying me much as a user. Since I was doing all the development myself, I preferred to build a monolithic Web application. I chose SQLite for the database, which meant one less component to install and configure.

In addition to the Web server, I needed some way to periodically poll the feeds for content. The simplest option would have been a cron job, but that seemed inconvenient, at least for the local setup. I had used task runners like Celery for that purpose in the past, but that required adding a couple of extra components: another service to run alongside the app and something like Redis to act as a broker. Could I get away with running background tasks in the same process as the application? That largely depended on the runtime of the language, which brings me to the next section.

*** Programming language

At least from my superficial understanding of it, Go seemed like the best fit for this project: a simple, general-purpose language, garbage-collected but fast enough, with a solid concurrency model and, most importantly for my requirements, one that produced easy-to-deploy binaries. (I later read [[https://miniflux.app/opinionated.html#golang][a similar case]] for Golang from the Miniflux author). The big problem was that I'd never written a line of Go, and while I understood it's a fairly accessible language to pick up, I didn't want to lose focus by turning this into a learning project.

Among the languages I was already fluent in, I needed to choose the one I expected to be most productive with, the one that let me build a prototype to decide whether this project was worth pursuing. So I chose Python.

The bad side of using Python was that I had to deal with its environment and dependency quirks, particularly its reliance on the host OS libraries. Additionally, it meant I'd have to get creative if I wanted to avoid extra components for the periodic tasks. (After some research I ended up choosing gevent and [[https://huey.readthedocs.io/en/latest/contrib.html#mini-huey][an extension of the Huey library]] to run them inside the application process). The good side was that I could leverage Python's libraries for HTTP, feed parsing, scraping, and database access.

*** Testing (or lack thereof)
Perhaps the most controversial aspect of the project was that I decided not to bother writing tests, at least initially. In a sense, this felt "dirty", but I still think it was the right call given what I was trying to do:

1. Unit tests don't work as a design tool for me. While I see the value of TDD and think everyone should try it at some point, I've found that the point of view it enforces doesn't align well with how I prefer to reason about programming tasks.
2. Given that I was going to experiment, adding, removing, and rearranging features, the cost of maintaining the tests outweighed the value they were going to provide. I didn't mind introducing little logic bugs; I was going to use the app myself anyway, so I expected that most significant bugs would just surface over time.
3. In my experience, integration tests are the ones that provide the most value in terms of confidence that the application works as expected. More so for this project, where the bulk of the work (and the majority of the bugs) came either from interacting with external sources or from the UI. While I could have caught some bugs earlier and prevented some regressions if I had integration tests in place, implementing them required an effort (e.g. serving arbitrary RSS feeds locally for testing different scenarios) that just wasn't worth upfront. (Now that the application is stable, though, I would consider adding some tests before attempting a significant code change).

** Development

There's a kind of zen flow that programmers unblock when they use their software daily. I don't mean just testing it but experiencing it as an end user. There's no better catalyst for ideas and experimentation, no better prioritization driver than having to face the bugs, annoyances, and limitations of an application first-hand.

[TODO desktop screenshot?]

After some trial and error with different UI layouts and features, a usage pattern emerged: open the app, scroll down the main feed, pin what I want to read later, open what I want to read now,  favorite if I want to save it for future reference.

I decided early on that I wanted the option to read articles without leaving the app (among other things, to avoid paywalls and consent popups). I tried several Python libraries to extract HTML content, but none worked as well as the [[https://github.com/mozilla/readability][readability]] one used by Firefox. Since it's a JavaScript package, I had to resign myself to adding an optional dependency on Node.js. (I ended up using the same logic to send articles to my Kindle, which not only saves me from using Amazon's Chrome extension but actually renders better content).

[TODO reader screenshot]

With the basic functionality in place, a problem became apparent. My feed mixed sources of  varying quality and publication frequency. Even after curating the list of feeds and carefully distributing them in folders, it was hard to get interesting content by just scrolling items by their publication date: occasional blog posts would get buried behind Mastodon toots, magazine features behind daily news articles.

So I started to think about how to make entry sorting "smarter". My reasoning was this: assuming I only follow sources I'm interested in, I'll likely want to first see content from the ones that publish more sparingly. If a monthly newsletter came out in the last couple of days, that should show up at the top of my feed, before any micro-blogging or daily news items. So I classified sources into "frequency buckets" and sorted the feed to show the least frequent buckets first.

Now, the problem was that when infrequent sources /did/ publish, their articles stuck at the top every time I opened the app. For a while, I tried trashing or archiving them, but this was a lot of extra work and pulled me in the direction of the "clear the inbox" flow that I was trying to avoid.
I wanted the app to do the work for me, by default, so I came up with this: as I scroll down the feed, previous items get marked automatically as "already seen"; the next time I open the app the seen articles will be skipped, so I'm always getting the least frequent /unseen/ content first.

#+BEGIN_CENTER
\ast{} \ast{} \ast{}
#+END_CENTER

At first, I left the app running on a terminal tab on my laptop, and I used it while I worked on it. Once I noticed interesting content showing up in the feed, I set up a Raspberry Pi server in my local network, to have a non-development instance running all the time. This, in turn, encouraged me to improve the mobile rendering of the interface, so I could access it from my phone.

[TODO mobile screenshot]

I eventually reached a point where I /missed/ having the app available when I was out, so I decided to deploy it to a VPS. This forced me to finally add the authentication and multi-user support I'd been postponing and allowed me to give access to a few friends for beta testing. (The VPS setup also encouraged me to buy a domain and set up this website, getting me closer to the IndieWeb ideal that inspired me in the first place).

** Conclusion

It took me about 3 months of (relaxed) work to put together my personal feed reader, which I named [[https://github.com/facundoolano/feedi][feedi]]. I can say that I succeeded in reengaging with software development, and in building something that I like to use myself, every day. Far from a finished product, the project feels more like my Emacs editor config: a perpetually half-broken tool that can nevertheless become second nature, hard to justify from a productivity standpoint but fulfilling because it was built on my own terms.

I've been using feedi as my "front page of the internet" for a few months now.
Beyond convenience, by using a personal reader I'm back in control of the information I consume, actively on the lookout for interesting blogs and magazines, better positioned for discovery and even surprise.

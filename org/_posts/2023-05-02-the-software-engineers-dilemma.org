#+OPTIONS: toc:nil num:nil
#+LANGUAGE: es
#+BEGIN_EXPORT html
---
layout: post
title: "The software engineer's dilemma"
date: 2023-05-02 16:17:11
translation: true
tags: üá¨üáß
---
#+END_EXPORT

# FIXME link
/This was/ [[file:../../2022-04-11-el-dilema-del-ingeniero-de-software][/originally published in spanish/]] /a year ago./

<INTRO>El VC sigue el mismo /modus operandi/ porque, con toda la informaci√≥n y el asesoramiento que el dinero puede comprar, identificar a una startup ganadora es una tarea improbable[fn:4]. Es m√°s realista diversificar: apostar a veinte o cien y, cuando una es un hit, recuperar toda la inversi√≥n.

El problema del programador que elige trabajar en una startup es que no tiene la opci√≥n de diversificar. El programador de startup se juega su fuerza de trabajo, que es aproximadamente todo su capital, en una sola apuesta. Por m√°s convencido que est√© de su elecci√≥n, por m√°s esfuerzo que ponga de su parte para que el producto sea exitoso, es un objetivo que en mayor medida escapa a su control. El programador de startup compra un boleto de loter√≠a pero sabe que tiene todas las de perder.

Poco me preocupan las consecuencias econ√≥micas de esta elecci√≥n cuando, a√∫n en su casi seguro fracaso, cualquier programador va a gozar de niveles de bienestar ins√≥litamente superiores a los del resto de la sociedad. Lo que me interesa es el lado B de esa elecci√≥n de carrera, lo que implica para el programador o el ingeniero de software optar entre un proyecto verde y uno maduro para desarrollar su actividad. Ah√≠ est√° el dilema.

#+BEGIN_CENTER
\ast{} \ast{} \ast{}
 #+END_CENTER

La historia de la profesi√≥n, los libros y las universidades nos ense√±aron a programar pensando en el largo plazo, tomando decisiones que favorezcan la sostenibilidad de los sistemas. La tarea del desarrollador no se limita a producir c√≥digo que funcione sino que debe buscar oportunidades para reducir la complejidad del software o, como me gusta decir a m√≠, disminuir la entrop√≠a del Universo. As√≠ lo explica John Ousterhout[fn:1]:

#+begin_quote
If we want to make it easier to write software, so that we can build more powerful systems more cheaply, we must find ways to make software simpler. Complexity will still increase over time, in spite of our best efforts, but simpler designs allow us to build larger and more powerful systems before complexity becomes overwhelming. (...) The first step towards becoming a good software designer is to realize that working code isn‚Äôt enough. It‚Äôs not acceptable to introduce unnecessary complexities in order to finish your current task faster. The most important thing is the long-term structure of the system. Most of the code in any system is written by extending the existing code base, so your most important job as a developer is to facilitate those future extensions. Thus, you should not think of ‚Äúworking code‚Äù as your primary goal, though of course your code must work. Your primary goal must be to produce a great design, which also happens to work. This is strategic programming. Strategic programming requires an investment mindset. Rather than taking the fastest path to finish your current project, you must invest time to improve the design of the system. These investments will slow you down a bit in the short term, but they will speed you up in the long term.
#+end_quote

Las startups son por definici√≥n pura t√°ctica y poca o ninguna estrategia. Todo conspira en contra del pensamiento de largo plazo: lo que importa es llegar a la pr√≥xima entrega, la pr√≥xima demo, la pr√≥xima ronda de inversi√≥n. ¬øC√≥mo puede importar la deuda t√©cnica acumulada si tal vez no haya producto ni empresa en seis meses?

#+begin_quote
If you are in a company leaning in this direction, you should realize that once a code base turns to spaghetti, it is nearly impossible to fix. You will probably pay high development costs for the life of the product. Furthermore, the payoff for good (or bad) design comes pretty quickly, so there‚Äôs a good chance that the tactical approach won‚Äôt even speed up your first product release.
#+end_quote


Creo que en esto Ousterhout exagera o peca de ingenuo. Hace falta una cantidad considerable de tiempo para recuperar la inversi√≥n, para que la calidad del c√≥digo en un proyecto joven llegue a tener un impacto tangible para alguien que no sea programador. Ser√≠a imprudente abogar intransigentemente por el mejor dise√±o posible en contextos donde la supervivencia de la organizaci√≥n pasa m√°s por el marketing y las finanzas que por la calidad futura del producto. Como dijo Gandalf, el ingeniero tiene que hacer lo mejor que pueda con el tiempo que le dan. Por oficio o por √©tica profesional, va a tratar de hacer las cosas bien, como le ense√±aron: va a pensar estrat√©gicamente, aunque solo pueda ejecutar una peque√±a parte de lo que crea necesario. El verdadero problema es que, aunque obre de buena fe, el √∫nico tipo de decisiones que puede tomar son decisiones prematuras[fn:3]:

#+begin_quote
Your early decisions make the biggest impact on the eventual shape of your system. The earliest decisions you make can be the hardest ones to reverse later. These early decisions about the system boundary and decomposition into subsystems get crystallized into the team structure, funding allocation, program management structure, and even time-sheet codes. Team assignments are the first draft of the architecture. It's a terrible irony that these very early decisions are also the least informed. The beginning is when your team is most ignorant of the eventual structure of the software, yet that's when some of the most irrevocable decisions must be made.
#+end_quote

Volvamos al hecho de que la mayor√≠a de las startups fracasan. De la misma forma que hace una apuesta arriesgada econ√≥micamente, el programador que elige una startup se est√° resignando a trabajar en software que posiblemente nunca llegue a producci√≥n o que termine teniendo un nivel de uso muy por debajo de los planes. La iron√≠a es que las suposiciones con las que justifica la sostenibilidad de su dise√±o y la escalabilidad de su arquitectura nunca van a llegar a ser puestas a prueba; est√° trabajando en proyectos de laboratorio, castillos en el aire, /software imaginario/.

#+BEGIN_CENTER
\ast{} \ast{} \ast{}
 #+END_CENTER

En el extremo opuesto a la startup tenemos a la empresa rentable, con un modelo de negocio definido, con usuarios, con software que ya est√° en producci√≥n, a veces hace tanto tiempo que lo llamamos /legacy/. Este es el /software realmente existente/ y, si bien el programador que se ocupa de √©l decididamente no construye castillos en el aire, ¬øest√° construyendo algo? M√°s bien parece dedicado a aterrizar castillos concebidos por otros, hace mucho tiempo, unos que probablemente ya se fueron a otra empresa.

As√≠ como al c√≥digo se lo lee m√°s frecuentemente de lo que se lo escribe, los sistemas son  operados y mantenidos m√°s de lo que se los dise√±a. En el software realmente existente los cambios de dise√±o son lentos, progresivos, a largo plazo, muchas veces dif√≠ciles de justificar econ√≥micamente. Empezar de cero suele ser temerario o inviable.

Esta realidad parece incompatible con la formaci√≥n del ingeniero de software, preparado para dise√±ar sistemas, concebir arquitecturas estrat√©gicamente y administrar su evoluci√≥n. Ni coincide con las inclinaciones de la mayor√≠a de los que elegimos esta profesi√≥n, con nuestro inter√©s por aplicar tecnolog√≠as modernas y construir herramientas sofisticadas. En el software realmente existente un monolito tiene m√°s esperanza de vida que un conjunto de microservicios; es m√°s rentable guardar archivos en S3 que operar una base de datos distribuida; una single-page application de React tiene menos chances de ganar el mercado que un [[https://twitter.com/levelsio/status/1308145873843560449][single-file PHP website]]. Marianne Belloti da en la tecla en la introducci√≥n de su libro /Kill It with Fire/[fn:2]:

#+begin_quote
We are past the point wherre all technical conversations and knowledge sharing can be about building new things. We have too many old things. People from my father's generation wrote a lot of programs, and every year they are shocked by how much of their work survives, still running in a production system somewhere. My generation has programmed exponentially more, infecting every aspect of life with a computer chip and some runtime instructions. We will be similarly shocked when those systems are still in place 30, 40, or 50 years from now.

Because we don't talk about modernizing old tech, organizations fall into the same traps over and over again. Failure is predictable beacuse so many software engineers think the conversations about modernizing legacy techonology are not relevant to their careers. Some of them are honestly surprised to find out that COBOL still runs much of the financial sector, that the majority of the web is still written in PHP, or that people are still looking to hire software engineers with ActionScript, Flash, and Visual Basic skills.
#+end_quote

Entonces, este es el dilema del ingeniero de software: nos preparamos por a√±os para dise√±ar sistemas estables que sobrevivan a largo plazo, pero tenemos que elegir entre el software imaginario, en el que la calidad de nuestro trabajo es indefinida y en √∫ltima instancia indiferente, y el software realmente existente, que ya fue dise√±ado, cuyo mantenimiento es pr√°cticamente una disciplina en s√≠ misma, mucho menos glamorosa que la que nos dictan los libros, las universidades y las conferencias.

#+BEGIN_CENTER
\ast{} \ast{} \ast{}
 #+END_CENTER

No voy a negar los m√©ritos de quienes saben identificar a un unicornio, ni mucho menos de los que ayudaron a concebir uno. Para ellos, mis felicitaciones. El problema es que su √©xito no es reproducible: son ejemplos de emprendedorismo, pero no pueden ser modelos para la profesi√≥n, de la misma manera que los ganadores de la loter√≠a no pueden ser modelos de movilidad social. Tiene que haber un camino de carrera realista para la ingenier√≠a de software, uno que todav√≠a sirva cuando los capitalistas se acuerden de generar ganancias y las startups tengan que rendir cuentas de lo que hacen.

El software realmente existente es, en definitiva, el √∫nico software del futuro. Suponiendo que todav√≠a quede una civilizaci√≥n, ya acomodados en nuestro rol hist√≥rico de plomeros digitales, vamos a dedicarnos a eso: a convivir con las decisiones de nuestros predecesores, administrar la complejidad del software, disminuir la entrop√≠a del Universo.

* Footnotes

[fn:4] /[[https://www.investopedia.com/articles/personal-finance/040915/how-many-startups-fail-and-why.asp][How Many Startups Fail and Why?]]/

[fn:3] Michael T. Nygard, /Release It!/

[fn:2] Marianne Bellotti, /Kill It with Fire/.

[fn:1] John Ousterhout, /A Philosophy of Software Design/.
